<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%=exam.name%></title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<!-- Add these lines in the <head> section, after the Font Awesome link -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/monokai.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/python/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/clike/clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/selection/active-line.min.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: #3b82f6;
            --primary-dark: #1d4ed8;
            --secondary: #6b7280;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #111827;
            --light: #f9fafb;
            --white: #ffffff;
            --border: #e5e7eb;
            --border-radius: 0.5rem;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: #f3f4f6;
            color: var(--dark);
            line-height: 1.6;
        }

        /* Header Styles */
        .header {
            background-color: var(--white);
            padding: 1rem 2rem;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .header-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .timer-display {
            background-color: var(--white);
            color: var(--dark);
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timer-critical {
            animation: pulse-red 2s infinite;
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* Main Container Styles */
        .main-container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 2rem;
        }




        /* ✅ UPDATED CSS: Better styles for code formatting in MCQ questions */

.question-with-code {
    line-height: 1.6;
}

.code-block {
    background-color: #2d3748;
    color: #e2e8f0;
    padding: 20px;
    border-radius: 8px;
    font-family: 'Courier New', Consolas, Monaco, 'Liberation Mono', monospace;
    font-size: 14px;
    line-height: 1.4;
    margin: 16px 0;
    overflow-x: auto;
    border-left: 4px solid #4a90e2;
    white-space: pre-wrap; /* Preserves spacing and allows wrapping */
    word-wrap: break-word;
    
    /* ✅ ADDED: Better syntax highlighting colors */
    /* Keywords will appear in different colors if you add syntax highlighting later */
}

/* ✅ ADDED: Specific styling for C syntax elements */
.code-block {
    /* Make sure HTML entities display correctly */
    word-break: normal;
    overflow-wrap: break-word;
}

/* ✅ ENHANCED: Better styling for existing question title */
.question-title {
    color: #2d3748;
    margin-bottom: 20px;
    font-size: 18px;
    font-weight: 600;
    line-height: 1.5;
}

/* ✅ OPTIONAL: Dark theme support */
@media (prefers-color-scheme: dark) {
    .code-block {
        background-color: #1a202c;
        color: #cbd5e0;
        border-left-color: #63b3ed;
    }
    
    .question-title {
        color: #f7fafc;
    }
}

/* ✅ RESPONSIVE: Better mobile display */
@media (max-width: 768px) {
    .code-block {
        font-size: 13px;
        padding: 16px;
        margin: 12px 0;
        border-radius: 6px;
    }
    
    .question-title {
        font-size: 16px;
    }
}




        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Question Content Styles */
        .question-panel {
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .question-header {
            background-color: var(--primary);
            color: var(--white);
            padding: 1rem 1.5rem;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-badges {
            display: flex;
            gap: 0.5rem;
        }

        .badge {
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-EASY {
            background-color: #bbf7d0;
            color: #166534;
        }

        .badge-MEDIUM {
            background-color: #fef08a;
            color: #854d0e;
        }

        .badge-HARD {
            background-color: #fecaca;
            color: #991b1b;
        }

        .badge-category {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .badge-marks {
            background-color: #e9d5ff;
            color: #6b21a8;
        }

        .question-content {
            padding: 1.5rem;
        }

        .question-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #fff;
        }

        .question-description {
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 1rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section-title i {
            color: var(--primary);
        }

        pre {
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 1rem;
        }

        /* MCQ Options Styles */
        .mcq-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .mcq-option {
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }

        .mcq-option:hover {
            background-color: #f1f5f9;
            border-color: #d1d5db;
        }

        .mcq-option.selected {
            background-color: #dbeafe;
            border-color: var(--primary);
        }

        .mcq-option input[type="radio"] {
            margin-right: 0.75rem;
            cursor: pointer;
            height: 1.2rem;
            width: 1.2rem;
        }

        .mcq-option label {
            cursor: pointer;
            flex: 1;
        }

        /* Code Editor Styles */
        .editor-section {
            margin-top: 2rem;
            border-top: 1px solid var(--border);
            padding-top: 1.5rem;
        }

.language-selector {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
    padding: 1rem;
    background-color: #f8fafc;
    border-radius: var(--border-radius);
    border: 1px solid var(--border);
}
body.dark-theme .language-selector {
    background-color: #2d2d3f;
    border-color: #374151;
}

      .language-selector label {
    font-weight: 600;
    color: var(--dark);
    white-space: nowrap;
}

body.dark-theme .language-selector label {
    color: #e5e7eb;
}

.language-selector select {
    padding: 0.75rem 1rem;
    border: 1px solid var(--border);
    border-radius: var(--border-radius);
    background-color: var(--white);
    font-size: 0.95rem;
    cursor: pointer;
    min-width: 200px;
    transition: all 0.2s ease;
}

   .language-selector select:hover {
    border-color: var(--primary);
}

.language-selector select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

body.dark-theme .language-selector select {
    background-color: #374151;
    color: #e5e7eb;
    border-color: #4b5563;
}

/* Enhanced Code Editor Container */
.code-editor {
    border: 2px solid var(--border);
    border-radius: var(--border-radius);
    overflow: hidden;
    background-color: var(--white);
    transition: border-color 0.2s ease;
    position: relative;
}

.code-editor:focus-within {
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}
body.dark-theme .code-editor {
    background-color: #1e1e1e;
    border-color: #374151;
}
.code-textarea {
    width: 100%;
    min-height: 450px;
    height: 450px;
    max-height: 600px;
    padding: 15px;
    font-family: 'Consolas', 'Monaco', 'Courier New', 'Fira Code', monospace;
    font-size: 15px;
    line-height: 1.5;
    border: none;
    resize: vertical;
    background-color: #ffffff;
    color: #1f2937;
    outline: none;
    tab-size: 4;
    -moz-tab-size: 4;
}

.code-textarea:focus {
    outline: none;
}

body.dark-theme .code-textarea {
    background-color: #1e1e1e;
    color: #e5e7eb;
}

/* Enhanced Editor Buttons */
.editor-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-top: 1.5rem;
    padding: 1rem;
    background-color: #f8fafc;
    border-radius: var(--border-radius);
    border: 1px solid var(--border);
}

body.dark-theme .editor-buttons {
    background-color: #2d2d3f;
    border-color: #374151;
}

.editor-buttons .btn {
    flex: 1;
    min-width: 140px;
    padding: 0.75rem 1rem;
    font-size: 0.95rem;
    font-weight: 600;
    border-radius: var(--border-radius);
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
}

.editor-buttons .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.editor-buttons .btn:active {
    transform: translateY(0);
}

        /* Button Styles */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background-color: var(--primary);
            color: var(--white);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--white);
            color: var(--secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background-color: #f8fafc;
        }

        .btn-success {
            background-color: var(--success);
            color: var(--white);
        }

        .btn-success:hover {
            background-color: #059669;
        }

        .btn-danger {
            background-color: var(--danger);
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .btn-lg {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
        }

        /* Test Results Styles */
       .results-section {
    margin-top: 2rem;
    border-top: 1px solid var(--border);
    padding-top: 1.5rem;
}

.result-output {
    background-color: #f8fafc;
    border: 1px solid var(--border);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    margin-bottom: 1rem;
}


        .result-summary {
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .result-pass {
            color: var(--success);
            font-weight: 600;
        }

        .result-fail {
            color: var(--danger);
            font-weight: 600;
        }

        .test-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .test-results-table th, 
        .test-results-table td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border);
            text-align: left;
        }

        .test-results-table th {
            background-color: #f8fafc;
            font-weight: 600;
        }

        .test-details-link {
            color: var(--primary);
            cursor: pointer;
            text-decoration: underline;
        }

        .diff-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 1rem;
        }

        .diff-expected, 
        .diff-actual {
            padding: 1rem;
            border-radius: 0.25rem;
        }

        .diff-expected {
            background-color: #f0fdf4;
            border: 1px solid #bbf7d0;
        }

        .diff-actual {
            background-color: #fef2f2;
            border: 1px solid #fecaca;
        }

        /* Sidebar Styles */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .sidebar-card {
            background-color: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .sidebar-header {
            background-color: var(--primary);
            color: var(--white);
            padding: 0.75rem 1rem;
            font-weight: 600;
        }

        .sidebar-content {
            padding: 1rem;
        }

        /* Navigation Styles */
        .question-navigation {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }

        .nav-button {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-button:hover {
            background-color: #f1f5f9;
        }

        .nav-button.active {
            background-color: var(--primary);
            color: var(--white);
            border-color: var(--primary);
        }

        .nav-button.unanswered {
            border: 2px solid var(--danger);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            70% {
                box-shadow: 0 0 0 5px rgba(239, 68, 68, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        .nav-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .nav-controls button {
            flex: 1;
        }

        /* Submit Container */
        .submit-container {
            padding: 1rem;
            text-align: center;
        }

        .submit-btn {
            width: 100%;
            padding: 0.75rem;
            background-color: var(--success);
            color: var(--white);
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .submit-btn:hover {
            background-color: #059669;
        }

        /* Progress Styles */
        .progress-container {
            margin-top: 0.5rem;
        }

        .progress-bar {
            height: 0.5rem;
            background-color: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            border-radius: 9999px;
            transition: width 0.3s ease;
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            color: var(--secondary);
        }

        /* Custom Test Section */
        .custom-test-section {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border);
            padding-top: 1.5rem;
        }

        .custom-input-textarea {
            width: 100%;
            min-height: 100px;
            padding: 1rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            resize: vertical;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        /* Tooltip Styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }
body.dark-theme .result-output {
    background-color: #2d2d3f;
    border-color: #374151;
}

.execution-output {
    background-color: var(--white);
    border: 1px solid var(--border);
    border-radius: var(--border-radius);
    padding: 1rem;
    margin: 1rem 0;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.4;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 300px;
    overflow-y: auto;
}

body.dark-theme .execution-output {
    background-color: #1e1e1e;
    color: #e5e7eb;
    border-color: #374151;
}

.execution-status {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-radius: var(--border-radius);
    font-weight: 600;
    margin-bottom: 1rem;
}

.execution-details {
    display: flex;
    gap: 2rem;
    flex-wrap: wrap;
    margin-top: 1rem;
    font-size: 0.9rem;
    color: var(--secondary);
}

.execution-details p {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin: 0;
}

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: var(--dark);
            color: var(--white);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.75rem;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        /* Dark Mode Toggle */
        .dark-mode-toggle {
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            background-color: transparent;
            color: var(--secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .dark-mode-toggle:hover {
            background-color: #f1f5f9;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .main-container {
                margin: 1rem auto;
                padding: 0 0.75rem;
            }

            .question-header {
                padding: 0.75rem 1rem;
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .question-content {
                padding: 1rem;
            }

            .diff-view {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <style>
    
.CodeMirror {
    height: 450px !important; /* Increased height */
    min-height: 450px;
    max-height: 600px; /* Allow some expansion */
    border: none;
    border-radius: var(--border-radius);
    font-family: 'Consolas', 'Monaco', 'Courier New', 'Fira Code', monospace;
    font-size: 15px; /* Slightly larger font */
    line-height: 1.5;
    resize: vertical; /* Allow vertical resizing */
}

.CodeMirror-scroll {
    min-height: 450px;
    padding: 10px 0; /* Add some padding */
}

.CodeMirror-lines {
    padding: 10px 0; /* Better spacing */
}

.CodeMirror-line {
    padding: 0 10px; /* Better horizontal padding */
}

/* Enhanced line numbers */
.CodeMirror-gutters {
    border-right: 1px solid #e1e5e9;
    background-color: #f8fafc;
    padding-right: 10px;
}

body.dark-theme .CodeMirror-gutters {
    background-color: #2d2d2d;
    border-color: #374151;
    color: #6b7280;
}

.CodeMirror-linenumber {
    color: #6b7280;
    font-size: 13px;
    padding: 0 8px 0 0;
    text-align: right;
    min-width: 30px;
}

body.dark-theme .CodeMirror-linenumber {
    color: #9ca3af;
}

/* Active line highlighting */
.CodeMirror-activeline-background {
    background-color: rgba(37, 99, 235, 0.05) !important;
}

body.dark-theme .CodeMirror-activeline-background {
    background-color: rgba(59, 130, 246, 0.1) !important;
}

/* Selection highlighting */
.CodeMirror-selected {
    background-color: rgba(37, 99, 235, 0.2) !important;
}

body.dark-theme .CodeMirror-selected {
    background-color: rgba(59, 130, 246, 0.3) !important;
}

/* Cursor */
.CodeMirror-cursor {
    border-left: 2px solid var(--primary);
    animation: blink 1s infinite;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

.CodeMirror-focused .CodeMirror-selected {
    background: rgba(59, 130, 246, 0.3);
}

.CodeMirror-line {
    padding: 0 4px;
}

/* Ensure CodeMirror works well with existing layout */
.code-editor .CodeMirror {
    margin-top: 0;
}
.code-editor-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background-color: #f1f5f9;
    border-bottom: 1px solid var(--border);
    font-size: 0.85rem;
    color: var(--secondary);
}

body.dark-theme .code-editor-toolbar {
    background-color: #374151;
    border-color: #4b5563;
    color: #9ca3af;
}

.code-editor-info {
    display: flex;
    gap: 1rem;
}

.code-editor-actions {
    display: flex;
    gap: 0.5rem;
}

.code-editor-actions button {
    padding: 0.25rem 0.5rem;
    border: 1px solid var(--border);
    background-color: var(--white);
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.8rem;
}

body.dark-theme .code-editor-actions button {
    background-color: #4b5563;
    border-color: #6b7280;
    color: #e5e7eb;
}

.custom-input-textarea {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
}
    </style>
</head>
<body>
    <p id="camneed" hidden><%=exam.settings.camera%></p>
    <p id="user" hidden><%=user._id%></p>
<p id="exam" hidden><%=exam._id%></p>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="header-logo">
                <i class="fas fa-graduation-cap"></i> PrepZer0 Exam
            </div>
            <div class="header-title" id="examTitle">Loading exam...</div>
        </div>
        <div class="header-right">
            <div class="timer-display" id="examTimer">
                <i class="fas fa-clock"></i> --:--:--
            </div>
            <div class="dark-mode-toggle" id="darkModeToggle">
                <i class="fas fa-moon"></i>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Question Panel -->
        <div class="question-panel">
            <div class="question-header">
                <div class="question-number" id="questionNumber">Question</div>
                <div class="question-badges" id="questionBadges"></div>
            </div>
            <div class="question-content" id="questionContainer">
                <div class="loading-container">
                    <p>Loading question...</p>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Navigation Card -->
            <div class="sidebar-card">
                <div class="sidebar-header">
                    <i class="fas fa-map-marker-alt"></i> Question Navigation
                </div>
                <div class="sidebar-content">
                    <div class="question-navigation" id="questionNavigation"></div>
                    
                    <div class="nav-controls">
                        <button class="btn btn-secondary" id="prevQuestion" disabled>
                            <i class="fas fa-arrow-left"></i> Previous
                        </button>
                        <button class="btn btn-secondary" id="nextQuestion" disabled>
                            Next <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Progress Card -->
            <div class="sidebar-card">
                <div class="sidebar-header">
                    <i class="fas fa-tasks"></i> Exam Progress
                </div>
                <div class="sidebar-content">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-stats">
                            <span id="answeredQuestions">0 answered</span>
                            <span id="totalQuestions">0 total</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Exam Info Card -->
            <div class="sidebar-card">
                <div class="sidebar-header">
                    <i class="fas fa-info-circle"></i> Exam Information
                </div>
                <div class="sidebar-content">
                    <p><strong>Duration:</strong> <span id="examDuration">--</span></p>
                    <p><strong>Type:</strong> <span id="examType">--</span></p>
                    <div class="tooltip">
                        <i class="fas fa-question-circle"></i>
                        <span class="tooltip-text">Questions marked with a red border are unanswered</span>
                    </div>
                </div>
            </div>

            <!-- Submit Card -->
            <div class="sidebar-card">
                <div class="submit-container">
                    <button class="submit-btn" id="submitExam">
                        <i class="fas fa-paper-plane"></i> Submit Exam
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        const CopyPasteControl = (function() {
    let isExamActive = false;
    let allowedClipboardContent = null;
    const CLIPBOARD_KEY = 'examAllowedClipboard';
    
    /**
     * Initialize copy-paste control system
     */
    function init() {
        console.log('Initializing copy-paste control system...');
        
        // Clear any existing clipboard data
        localStorage.removeItem(CLIPBOARD_KEY);
        
        // Add global event listeners immediately
        setupGlobalListeners();
        
        return {
            start: startControl,
            stop: stopControl,
            setupCodeEditor: setupCodeEditorControl
        };
    }
    
    /**
     * Start copy-paste control (when exam begins)
     */
    function startControl() {
        isExamActive = true;
        allowedClipboardContent = null;
        localStorage.removeItem(CLIPBOARD_KEY);
        console.log('Copy-paste control activated');
        
        // Show notification about copy-paste restrictions
        if (typeof examIntegrity !== 'undefined' && examIntegrity.showNotification) {
            examIntegrity.showNotification(
                'Copy-paste is restricted during the exam. You can only copy/paste within code editors.',
                'warning'
            );
        }
    }
    
    /**
     * Stop copy-paste control (when exam ends)
     */
    function stopControl() {
        isExamActive = false;
        allowedClipboardContent = null;
        localStorage.removeItem(CLIPBOARD_KEY);
        console.log('Copy-paste control deactivated');
    }
    
    /**
     * Set up global event listeners for copy-paste prevention
     */
    function setupGlobalListeners() {
        // Use capture phase (true) to intercept events before they reach targets
        document.addEventListener('copy', handleGlobalCopy, true);
        document.addEventListener('paste', handleGlobalPaste, true);
        document.addEventListener('cut', handleGlobalCut, true);
        document.addEventListener('keydown', handleKeyboardShortcuts, true);
        
        // Prevent context menu globally
        document.addEventListener('contextmenu', (e) => {
            if (isExamActive && !isCodeEditor(e.target)) {
                e.preventDefault();
                showCopyPasteWarning('Right-click context menu is disabled during the exam.');
            }
        });
        
        // Clear clipboard when focus leaves code editor
        document.addEventListener('focusout', handleFocusOut);
        
        console.log('Global copy-paste event listeners set up');
    }
    
    /**
     * Handle global copy events
     */
    function handleGlobalCopy(e) {
        if (!isExamActive) return;
        
        const target = e.target;
        console.log('Copy event detected on:', target.tagName, target.className, target.id);
        
        // Check if the copy is from a code editor
        if (isCodeEditor(target)) {
            console.log('Copy allowed from code editor');
            // Allow copy from code editor and store the content
            handleCodeEditorCopy(e, target);
            return;
        }
        
        // Block copy from anywhere else
        console.log('Copy blocked - not from code editor');
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        showCopyPasteWarning('Copying is only allowed from code editors during the exam.');
        logCopyPasteViolation('copy_attempt');
        
        return false;
    }
    
    /**
     * Handle global paste events
     */
    function handleGlobalPaste(e) {
        if (!isExamActive) return;
        
        const target = e.target;
        console.log('Paste event detected on:', target.tagName, target.className, target.id);
        
        // Check if the paste is into a code editor
        if (isCodeEditor(target)) {
            console.log('Paste allowed into code editor');
            // Allow paste into code editor but validate content
            return handleCodeEditorPaste(e, target);
        }
        
        // Block paste anywhere else
        console.log('Paste blocked - not into code editor');
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        showCopyPasteWarning('Pasting is only allowed into code editors during the exam.');
        logCopyPasteViolation('paste_attempt');
        
        return false;
    }
    
    /**
     * Handle global cut events
     */
    function handleGlobalCut(e) {
        if (!isExamActive) return;
        
        const target = e.target;
        console.log('Cut event detected on:', target.tagName, target.className, target.id);
        
        // Check if the cut is from a code editor
        if (isCodeEditor(target)) {
            console.log('Cut allowed from code editor');
            // Allow cut from code editor and store the content
            handleCodeEditorCut(e, target);
            return;
        }
        
        // Block cut from anywhere else
        console.log('Cut blocked - not from code editor');
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        showCopyPasteWarning('Cutting text is only allowed from code editors during the exam.');
        logCopyPasteViolation('cut_attempt');
        
        return false;
    }
    
    /**
     * Handle keyboard shortcuts for copy/paste
     */
    function handleKeyboardShortcuts(e) {
        if (!isExamActive) return;
        
        const target = e.target;
        const isCtrlC = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c';
        const isCtrlV = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v';
        const isCtrlX = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'x';
        const isCtrlA = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a';
        
        if (isCtrlC || isCtrlV || isCtrlX) {
            console.log('Keyboard shortcut detected:', e.key, 'on', target.tagName, target.className);
            
            // If it's not a code editor, prevent the action
            if (!isCodeEditor(target)) {
                console.log('Keyboard shortcut blocked - not in code editor');
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                const action = isCtrlC ? 'copying' : isCtrlV ? 'pasting' : 'cutting';
                showCopyPasteWarning(`Keyboard ${action} is only allowed in code editors during the exam.`);
                logCopyPasteViolation(`keyboard_${action.replace('ing', '')}_attempt`);
                
                return false;
            } else {
                console.log('Keyboard shortcut allowed in code editor');
            }
        }
        
        // Allow Ctrl+A everywhere for better UX (selecting all text)
        if (isCtrlA) {
            return true;
        }
    }
    
    /**
     * Check if the target element is a code editor
     */
    function isCodeEditor(element) {
        if (!element) return false;
        
        // More comprehensive check for code editor
        const isCodeTextarea = element.classList.contains('code-textarea');
        const hasCodeEditorId = element.id && element.id.startsWith('codeEditor-');
        const isInCodeEditor = element.closest('.code-editor') !== null;
        const isInEditorSection = element.closest('.editor-section') !== null;
        const isCustomInput = element.classList.contains('custom-input-textarea') || 
                            (element.id && element.id.startsWith('custom-input-'));
        
        const result = isCodeTextarea || hasCodeEditorId || isInCodeEditor || isInEditorSection || isCustomInput;
        
        if (result) {
            console.log('Element identified as code editor:', {
                tagName: element.tagName,
                className: element.className,
                id: element.id,
                isCodeTextarea,
                hasCodeEditorId,
                isInCodeEditor,
                isInEditorSection,
                isCustomInput
            });
        }
        
        return result;
    }
    
    /**
     * Handle copy operation from code editor
     */
    function handleCodeEditorCopy(e, target) {
        setTimeout(() => {
            try {
                // Get the selected text
                const selectedText = target.value.substring(target.selectionStart, target.selectionEnd);
                
                if (selectedText) {
                    // Store the allowed clipboard content
                    allowedClipboardContent = selectedText;
                    localStorage.setItem(CLIPBOARD_KEY, JSON.stringify({
                        content: selectedText,
                        timestamp: Date.now(),
                        questionId: extractQuestionId(target)
                    }));
                    
                    console.log('Allowed copy from code editor:', selectedText.substring(0, 50) + '...');
                    showCopyPasteSuccess('Code copied successfully!');
                }
            } catch (error) {
                console.error('Error handling code editor copy:', error);
            }
        }, 10);
    }
    
    /**
     * Handle cut operation from code editor
     */
    function handleCodeEditorCut(e, target) {
        setTimeout(() => {
            try {
                // Get the selected text before it's cut
                const selectedText = target.value.substring(target.selectionStart, target.selectionEnd);
                
                if (selectedText) {
                    // Store the allowed clipboard content
                    allowedClipboardContent = selectedText;
                    localStorage.setItem(CLIPBOARD_KEY, JSON.stringify({
                        content: selectedText,
                        timestamp: Date.now(),
                        questionId: extractQuestionId(target)
                    }));
                    
                    console.log('Allowed cut from code editor:', selectedText.substring(0, 50) + '...');
                    showCopyPasteSuccess('Code cut successfully!');
                }
            } catch (error) {
                console.error('Error handling code editor cut:', error);
            }
        }, 10);
    }
    
    /**
     * Handle paste operation into code editor
     */
    function handleCodeEditorPaste(e, target) {
        e.preventDefault();
        
        try {
            // Get clipboard data
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedContent = clipboardData.getData('text/plain');
            
            console.log('Attempting to paste into code editor:', pastedContent.substring(0, 50) + '...');
            
            // Check if the pasted content is allowed
            if (!isContentAllowed(pastedContent)) {
                showCopyPasteWarning('You can only paste content that was copied from a code editor during this exam.');
                logCopyPasteViolation('unauthorized_paste_attempt');
                return false;
            }
            
            // Insert the content at cursor position
            const startPos = target.selectionStart;
            const endPos = target.selectionEnd;
            const beforeText = target.value.substring(0, startPos);
            const afterText = target.value.substring(endPos);
            
            target.value = beforeText + pastedContent + afterText;
            
            // Set cursor position after pasted content
            const newCursorPos = startPos + pastedContent.length;
            target.setSelectionRange(newCursorPos, newCursorPos);
            
            // Trigger input event to save changes
            const inputEvent = new Event('input', { bubbles: true });
            target.dispatchEvent(inputEvent);
            
            console.log('Allowed paste into code editor:', pastedContent.substring(0, 50) + '...');
            showCopyPasteSuccess('Code pasted successfully!');
            
            return true;
            
        } catch (error) {
            console.error('Error handling code editor paste:', error);
            showCopyPasteWarning('Failed to paste content. Please try again.');
            return false;
        }
    }
    
    /**
     * Check if content is allowed to be pasted
     */
    function isContentAllowed(content) {
        if (!content) return false;
        
        // Check against stored allowed content
        if (allowedClipboardContent === content) {
            return true;
        }
        
        // Check against localStorage stored content
        try {
            const storedData = localStorage.getItem(CLIPBOARD_KEY);
            if (storedData) {
                const parsed = JSON.parse(storedData);
                
                // Check if content matches and is not too old (within 1 hour)
                const isRecent = (Date.now() - parsed.timestamp) < (60 * 60 * 1000);
                
                if (parsed.content === content && isRecent) {
                    return true;
                }
            }
        } catch (error) {
            console.error('Error checking stored clipboard content:', error);
        }
        
        return false;
    }
    
    /**
     * Extract question ID from target element
     */
    function extractQuestionId(target) {
        if (target.id && target.id.startsWith('codeEditor-')) {
            return target.id.replace('codeEditor-', '');
        }
        return 'unknown';
    }
    
    /**
     * Handle focus out events
     */
    function handleFocusOut(e) {
        if (!isExamActive) return;
        
        const target = e.target;
        
        // If focus is leaving a code editor
        if (isCodeEditor(target)) {
            setTimeout(() => {
                const activeElement = document.activeElement;
                if (!isCodeEditor(activeElement)) {
                    // Optional: Clear allowed clipboard content when leaving code editor area
                    // Uncomment the lines below if you want to clear clipboard when leaving code editor
                    // allowedClipboardContent = null;
                    // localStorage.removeItem(CLIPBOARD_KEY);
                    // console.log('Cleared allowed clipboard content on focus out');
                }
            }, 100);
        }
    }
    
    /**
     * Set up individual code editor controls
     */
    function setupCodeEditorControl(questionId) {
        const codeEditor = document.getElementById(`codeEditor-${questionId}`);
        
        if (!codeEditor) {
            console.error(`Code editor not found for question: ${questionId}`);
            return;
        }
        
        console.log(`Setting up copy-paste control for code editor: ${questionId}`);
        
        // Mark this element as a code editor (additional safety)
        codeEditor.dataset.isCodeEditor = 'true';
        
        // No need to add specific event listeners here since global listeners handle everything
        console.log(`Copy-paste control set up for code editor: ${questionId}`);
    }
    
    /**
     * Show copy-paste warning message
     */
    function showCopyPasteWarning(message) {
        console.log('Showing copy-paste warning:', message);
        
        // Try to use existing notification system
        if (typeof examIntegrity !== 'undefined' && examIntegrity.showNotification) {
            examIntegrity.showNotification(message, 'error');
        } else {
            // Fallback notification
            const notification = createNotification(message, 'warning');
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }
    }
    
    /**
     * Show copy-paste success message
     */
    function showCopyPasteSuccess(message) {
        console.log('Showing copy-paste success:', message);
        
        // Try to use existing notification system
        if (typeof examIntegrity !== 'undefined' && examIntegrity.showNotification) {
            examIntegrity.showNotification(message, 'success');
        } else {
            // Fallback notification
            const notification = createNotification(message, 'success');
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }
    }
    
    /**
     * Create notification element
     */
    function createNotification(message, type) {
        const notification = document.createElement('div');
        notification.className = `copy-paste-notification ${type}`;
        
        const bgColor = type === 'warning' ? '#fff3cd' : type === 'success' ? '#d1fae5' : '#fee2e2';
        const textColor = type === 'warning' ? '#856404' : type === 'success' ? '#065f46' : '#991b1b';
        const borderColor = type === 'warning' ? '#ffeeba' : type === 'success' ? '#6ee7b7' : '#fca5a5';
        
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: ${bgColor};
            color: ${textColor};
            border: 1px solid ${borderColor};
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10000;
            max-width: 350px;
            transform: translateX(110%);
            transition: transform 0.3s ease;
            font-size: 14px;
            line-height: 1.4;
        `;
        
        notification.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-${type === 'warning' ? 'exclamation-triangle' : type === 'success' ? 'check-circle' : 'times-circle'}"></i>
                <span>${message}</span>
            </div>
        `;
        
        // Add show class for animation
        notification.classList.add = function(className) {
            if (className === 'show') {
                this.style.transform = 'translateX(0)';
            }
        };
        
        notification.classList.remove = function(className) {
            if (className === 'show') {
                this.style.transform = 'translateX(110%)';
            }
        };
        
        return notification;
    }
    
    /**
     * Log copy-paste violations
     */
    function logCopyPasteViolation(violationType) {
        console.log(`Copy-paste violation: ${violationType}`);
        
        // Try to use existing integrity system
        if (typeof examIntegrity !== 'undefined' && examIntegrity.getViolationCounts) {
            // You can extend the integrity system to handle copy-paste violations
        }
        
        // Send to server
        try {
            const examId = document.getElementById('exam')?.textContent;
            const userId = document.getElementById('user')?.textContent;
            
            if (examId && userId) {
                fetch('/update-integrity', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        examId: examId,
                        userId: userId,
                        eventType: `copyPaste_${violationType}`
                    })
                }).catch(error => {
                    console.error('Error logging copy-paste violation:', error);
                });
            }
        } catch (error) {
            console.error('Error sending copy-paste violation log:', error);
        }
    }
    
    /**
     * Get current clipboard status (for debugging)
     */
    function getClipboardStatus() {
        return {
            isExamActive,
            hasAllowedContent: !!allowedClipboardContent,
            allowedContentPreview: allowedClipboardContent ? allowedClipboardContent.substring(0, 50) + '...' : null,
            storedData: localStorage.getItem(CLIPBOARD_KEY)
        };
    }
    
    // Public API
    return {
        init,
        startControl,
        stopControl,
        setupCodeEditorControl,
        getClipboardStatus
    };
})();

// Initialize the system when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.copyPasteControl = CopyPasteControl.init();
    });
} else {
    window.copyPasteControl = CopyPasteControl.init();
}
    </script>
<script>

    /**
 * Camera Permission Handler for Exam Portal
 * 
 * This script handles camera permission checking and requesting
 * before allowing users to start the exam.
 */

const CameraPermissionHandler = (function() {
    let cameraStream = null;
    let permissionGranted = false;
    
    /**
     * Check if camera permissions are granted
     */
    async function checkCameraPermission() {
        try {
            // First check if navigator.permissions is supported (not available in all browsers)
            if (navigator.permissions && navigator.permissions.query) {
                const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                console.log('Camera permission status:', permissionStatus.state);
                
                if (permissionStatus.state === 'granted') {
                    return await testCameraAccess();
                } else if (permissionStatus.state === 'denied') {
                    return false;
                } else {
                    // Permission is 'prompt' - need to request access
                    return await requestCameraAccess();
                }
            } else {
                // Fallback: Try to access camera directly
                return await testCameraAccess();
            }
        } catch (error) {
            console.error('Error checking camera permission:', error);
            return false;
        }
    }
    
    /**
     * Test camera access by trying to get media stream
     */
    async function testCameraAccess() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 320 },
                    height: { ideal: 240 },
                    facingMode: "user"
                } 
            });
            
            // Stop the stream immediately after testing
            stream.getTracks().forEach(track => track.stop());
            console.log('Camera access test successful');
            return true;
        } catch (error) {
            console.error('Camera access test failed:', error);
            return false;
        }
    }
    
    /**
     * Request camera access from user
     */
    async function requestCameraAccess() {
        try {
            showCameraRequestModal();
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 320 },
                    height: { ideal: 240 },
                    facingMode: "user"
                } 
            });
            
            // Store the stream for later use
            cameraStream = stream;
            permissionGranted = true;
            
            hideCameraRequestModal();
            showSuccessMessage('Camera access granted successfully!');
            
            return true;
        } catch (error) {
            console.error('Camera access request failed:', error);
            hideCameraRequestModal();
            
            if (error.name === 'NotAllowedError') {
                showCameraErrorModal('Camera access denied. Please enable camera access in your browser settings and refresh the page.');
            } else if (error.name === 'NotFoundError') {
                showCameraErrorModal('No camera found. Please connect a camera and try again.');
            } else if (error.name === 'NotReadableError') {
                showCameraErrorModal('Camera is being used by another application. Please close other applications and try again.');
            } else {
                showCameraErrorModal('Failed to access camera. Please check your camera settings and try again.');
            }
            
            return false;
        }
    }
    
    /**
     * Show camera request modal
     */
    function showCameraRequestModal() {
        const modal = document.createElement('div');
        modal.id = 'cameraRequestModal';
        modal.className = 'camera-modal-overlay';
        modal.innerHTML = `
            <div class="camera-modal-content">
                <div class="camera-modal-header">
                    <h3><i class="fas fa-video"></i> Camera Access Required</h3>
                </div>
                <div class="camera-modal-body">
                    <p>This exam requires camera access for monitoring purposes.</p>
                    <p>Please allow camera access when prompted by your browser.</p>
                    <div class="camera-loading">
                        <i class="fas fa-spinner fa-spin"></i>
                        <span>Requesting camera access...</span>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    /**
     * Hide camera request modal
     */
    function hideCameraRequestModal() {
        const modal = document.getElementById('cameraRequestModal');
        if (modal) {
            modal.remove();
        }
    }
    
    /**
     * Show camera error modal
     */
    function showCameraErrorModal(message) {
        const modal = document.createElement('div');
        modal.id = 'cameraErrorModal';
        modal.className = 'camera-modal-overlay';
        modal.innerHTML = `
            <div class="camera-modal-content camera-error">
                <div class="camera-modal-header">
                    <h3><i class="fas fa-exclamation-triangle"></i> Camera Access Error</h3>
                </div>
                <div class="camera-modal-body">
                    <p>${message}</p>
                    <div class="camera-instructions">
                        <h4>To enable camera access:</h4>
                        <ul>
                            <li><strong>Chrome/Safari:</strong> Click the camera icon in the address bar</li>
                            <li><strong>Firefox:</strong> Click on the shield icon in the address bar</li>
                            <li><strong>Edge:</strong> Click on the lock icon in the address bar</li>
                        </ul>
                        <p>After enabling camera access, please refresh the page and try again.</p>
                    </div>
                </div>
                <div class="camera-modal-footer">
                    <button id="tryAgainBtn" class="btn btn-primary">
                        <i class="fas fa-redo"></i> Try Again
                    </button>
                    <button id="refreshPageBtn" class="btn btn-secondary">
                        <i class="fas fa-refresh"></i> Refresh Page
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Add event listeners
        document.getElementById('tryAgainBtn').addEventListener('click', async () => {
            modal.remove();
            await initializeCameraCheck();
        });
        
        document.getElementById('refreshPageBtn').addEventListener('click', () => {
            window.location.reload();
        });
    }
    
    /**
     * Show success message
     */
    function showSuccessMessage(message) {
        const notification = document.createElement('div');
        notification.className = 'camera-notification camera-success';
        notification.innerHTML = `
            <div class="notification-content">
                <i class="fas fa-check-circle"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    /**
     * Update start exam button state
     */
    function updateStartExamButton(enabled) {
        const startButton = document.getElementById('startExamButton');
        if (startButton) {
            startButton.disabled = !enabled;
            
            if (enabled) {
                startButton.innerHTML = '<i class="fas fa-play"></i> Start Exam';
                startButton.classList.remove('disabled');
            } else {
                startButton.innerHTML = '<i class="fas fa-video"></i> Camera Access Required';
                startButton.classList.add('disabled');
            }
        }
    }
    
    /**
     * Show camera status in the UI
     */
    function updateCameraStatus(status, message) {
        let statusElement = document.getElementById('cameraStatus');
        
        if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'cameraStatus';
            statusElement.className = 'camera-status';
            
            // Insert before the start button
            const startButton = document.getElementById('startExamButton');
            if (startButton && startButton.parentNode) {
                startButton.parentNode.insertBefore(statusElement, startButton);
            }
        }
        
        const iconClass = status === 'success' ? 'fa-check-circle' : 
                         status === 'error' ? 'fa-exclamation-circle' : 'fa-spinner fa-spin';
        
        statusElement.className = `camera-status camera-status-${status}`;
        statusElement.innerHTML = `
            <i class="fas ${iconClass}"></i>
            <span>${message}</span>
        `;
    }
    
    /**
     * Initialize camera permission check
     */
    async function initializeCameraCheck() {
        updateCameraStatus('checking', 'Checking camera access...');
        updateStartExamButton(false);
        
        try {
            const hasPermission = await checkCameraPermission();
            
            if (hasPermission) {
                permissionGranted = true;
                updateCameraStatus('success', 'Camera access granted');
                updateStartExamButton(true);
                return true;
            } else {
                updateCameraStatus('error', 'Camera access required');
                updateStartExamButton(false);
                return false;
            }
        } catch (error) {
            console.error('Error during camera initialization:', error);
            updateCameraStatus('error', 'Camera access error');
            updateStartExamButton(false);
            return false;
        }
    }
    
    /**
     * Get the camera stream (if already granted)
     */
    function getCameraStream() {
        return cameraStream;
    }
    
    /**
     * Check if permission is granted
     */
    function isPermissionGranted() {
        return permissionGranted;
    }
    
    /**
     * Clean up camera resources
     */
    function cleanup() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
        permissionGranted = false;
    }
    
    // Return public API
    return {
        initialize: initializeCameraCheck,
        checkPermission: checkCameraPermission,
        requestAccess: requestCameraAccess,
        getCameraStream: getCameraStream,
        isPermissionGranted: isPermissionGranted,
        cleanup: cleanup
    };
})();

// CSS Styles for camera permission modals and notifications
const cameraStyles = `
    .camera-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
    }
    
    .camera-modal-content {
        background-color: white;
        border-radius: 8px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        animation: slideUp 0.3s ease;
    }
    
    .camera-modal-content.camera-error {
        max-width: 600px;
    }
    
    .camera-modal-header {
        padding: 1.5rem;
        border-bottom: 1px solid #e5e7eb;
        background-color: #f9fafb;
        border-radius: 8px 8px 0 0;
    }
    
    .camera-modal-header h3 {
        margin: 0;
        color: #1f2937;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .camera-modal-body {
        padding: 1.5rem;
    }
    
    .camera-modal-body p {
        margin-bottom: 1rem;
        color: #4b5563;
        line-height: 1.6;
    }
    
    .camera-loading {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: #2563eb;
        font-weight: 500;
        margin-top: 1rem;
    }
    
    .camera-instructions {
        background-color: #f3f4f6;
        padding: 1rem;
        border-radius: 6px;
        margin-top: 1rem;
    }
    
    .camera-instructions h4 {
        margin: 0 0 0.75rem 0;
        color: #1f2937;
    }
    
    .camera-instructions ul {
        margin: 0.5rem 0;
        padding-left: 1.5rem;
    }
    
    .camera-instructions li {
        margin-bottom: 0.5rem;
        color: #4b5563;
    }
    
    .camera-modal-footer {
        padding: 1rem 1.5rem;
        border-top: 1px solid #e5e7eb;
        display: flex;
        gap: 0.75rem;
        justify-content: flex-end;
    }
    
    .camera-status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
        font-weight: 500;
    }
    
    .camera-status-checking {
        background-color: #dbeafe;
        color: #1e40af;
        border: 1px solid #93c5fd;
    }
    
    .camera-status-success {
        background-color: #d1fae5;
        color: #065f46;
        border: 1px solid #6ee7b7;
    }
    
    .camera-status-error {
        background-color: #fee2e2;
        color: #991b1b;
        border: 1px solid #fca5a5;
    }
    
    .camera-notification {
        position: fixed;
        top: 1rem;
        right: 1rem;
        max-width: 300px;
        z-index: 9999;
        border-radius: 6px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transform: translateX(110%);
        transition: transform 0.3s ease;
    }
    
    .camera-notification.show {
        transform: translateX(0);
    }
    
    .camera-notification .notification-content {
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .camera-success .notification-content {
        background-color: #ecfdf5;
        color: #064e3b;
        border-left: 4px solid #10b981;
    }
    
    .start-exam-button.disabled {
        background-color: #9ca3af !important;
        cursor: not-allowed !important;
        opacity: 0.6;
    }
    
    .start-exam-button.disabled:hover {
        background-color: #9ca3af !important;
        transform: none !important;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Dark theme styles */
    body.dark-theme .camera-modal-content {
        background-color: #1f2937;
        color: #e5e7eb;
    }
    
    body.dark-theme .camera-modal-header {
        background-color: #374151;
        border-color: #4b5563;
    }
    
    body.dark-theme .camera-modal-header h3 {
        color: #e5e7eb;
    }
    
    body.dark-theme .camera-modal-body p {
        color: #d1d5db;
    }
    
    body.dark-theme .camera-instructions {
        background-color: #374151;
    }
    
    body.dark-theme .camera-instructions h4 {
        color: #e5e7eb;
    }
    
    body.dark-theme .camera-instructions li {
        color: #d1d5db;
    }
    
    body.dark-theme .camera-modal-footer {
        border-color: #4b5563;
    }
`;

// Add styles to document
const cameraStyleElement = document.createElement('style');
cameraStyleElement.textContent = cameraStyles;
document.head.appendChild(cameraStyleElement);
// Integration function to modify the existing startExam function
function integrateWithExistingExam() {
    // Store the original startExam function
    const originalStartExam = window.startExam;
    
    // Override the startExam function
    window.startExam = function() {
        // Check if camera permission is granted before starting
        if (!CameraPermissionHandler.isPermissionGranted()) {
            alert('Camera access is required to start the exam. Please grant camera permission first.');
            return;
        }
        
        // Call the original startExam function
        if (originalStartExam) {
            originalStartExam.call(this);
        }
    };
    
    // Initialize camera check when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Wait a bit for the start overlay to be created
        needcam =document.getElementById('camneed').innerHTML;
        if(needcam === 'false') {
            
        }else{
        setTimeout(() => {
            CameraPermissionHandler.initialize();
        }, 500);
        }

    });
}

if (typeof window !== 'undefined') {
    if(document.getElementById("camneed").innerHTML == 'true'){
        integrateWithExistingExam();
    }
    
}
</script>


    <script>

/**
 * Exam Integrity Monitoring Module
 * 
 * This module provides functionality for:
 * 1. Integrity monitoring (tab changes, mouse exits, fullscreen controls, copy/paste prevention, etc.)
 * 2. Activity ping tracking to server
 * 3. Webcam capture and submission
 * 
 * Usage: Include this script and initialize with examIntegrity.init()
 */

const examIntegrity = (function() {
    // Configuration
    const config = {
        maxViolations: 999,                // Maximum violations before auto-submit
        maxRefreshes: 999,                 // Maximum allowed page refreshes
        pingInterval: 20000,             // Ping interval in ms (20 seconds)
        tabFocusCooldown: 1000,          // Time between focus events in ms
        webcamCaptureInterval: 5000,     // Webcam capture interval in ms
        resizeCooldown: 500,             // Time between resize events in ms
        maxResizeAttempts: 999             // Maximum resize attempts before violation
    };

    // State variables
    let state = {
        examStarted: false,
        isFullscreenActive: false,
        lastTabFocusTime: 0,
        pingIntervalId: null,
        resizeAttempts: 0,
        lastResizeTime: 0,
        submitting: false,
        autoSubmitCallback: null,        // Callback when auto submitting
        
        // Violation counters
        violations: {
            tabChangeCount: 0,
            mouseOutCount: 0,
            fullscreenExitCount: 0,
            // copyAttemptCount: 0,
            // pasteAttemptCount: 0,
            focusChangeCount: 0,
            refreshViolationCount: 0
        },
        totalViolations: 0
    };

    // DOM Elements (to be initialized)
    let elements = {
        tabChangeCount: null,
        mouseOutCount: null,
        fullscreenExitCount: null,
        copyAttemptCount: null,
        pasteAttemptCount: null,
        focusChangeCount: null,
        refreshViolationCount: null,
        totalViolations: null,
        lastEvent: null,
        notificationContainer: null
    };

    // URLs for API endpoints
    const apiEndpoints = {
        integrityUpdate: '/update-integrity',
        activityPing: '/dashboard/see-active',
        saveImage: '/save-image'
    };

    // User and exam info
    let examInfo = {
        examId: null,
        userId: null
    };

    /**
     * Initialize the integrity module
     * @param {Object} options Configuration options
     */
    function init(options = {}) {
        console.log('Initializing exam integrity module...');
        
        // Merge options with defaults
        if (options.config) {
            Object.assign(config, options.config);
        }
        
        // Set exam info
        if (options.examId) examInfo.examId = options.examId;
        if (options.userId) examInfo.userId = options.userId;
        
        // Initialize from localStorage if available
        state.examStarted = localStorage.getItem('examStarted') === 'true';
        
        // Auto-submit callback
        if (options.onAutoSubmit && typeof options.onAutoSubmit === 'function') {
            state.autoSubmitCallback = options.onAutoSubmit;
        }
        
        // Set API endpoints
        if (options.apiEndpoints) {
            Object.assign(apiEndpoints, options.apiEndpoints);
        }
        
        // Initialize UI elements
        initElements();
        
        // Initialize event listeners
        if (state.examStarted) {
            setupEventListeners();
            handleRefreshDetection();
            startActivityPing();
            
            if (options.startWebcam) {
                if(document.getElementById('camneed').innerHTML == 'true'){
                    startWebcamCapture();
                }
                
            }
        }
        
        // Add style for notifications
        const style = document.createElement('style');
        style.id = 'notificationAnimations';
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(-20px); }
            }
        `;
        document.head.appendChild(style);
        
        return {
            start,
            stop,
            enterFullscreen,
            handleRefreshDetection,
            startWebcamCapture,
            showNotification,
            getViolationCounts,
            preventBackButton
        };
    }

    /**
     * Initialize UI elements
     */
    function initElements() {
        // Get DOM elements for counters
        elements.tabChangeCount = document.getElementById('tabChangeCount');
        elements.mouseOutCount = document.getElementById('mouseOutCount');
        elements.fullscreenExitCount = document.getElementById('fullscreenExitCount');
        elements.copyAttemptCount = document.getElementById('copyAttemptCount');
        elements.pasteAttemptCount = document.getElementById('pasteAttemptCount');
        elements.focusChangeCount = document.getElementById('focusChangeCount');
        elements.refreshViolationCount = document.getElementById('refreshViolationCount');
        elements.totalViolations = document.getElementById('totalViolations');
        elements.lastEvent = document.getElementById('lastEvent');
        
        // Create notification container if it doesn't exist
        elements.notificationContainer = document.getElementById('notificationContainer');
        if (!elements.notificationContainer) {
            elements.notificationContainer = document.createElement('div');
            elements.notificationContainer.id = 'notificationContainer';
            elements.notificationContainer.style.position = 'fixed';
            elements.notificationContainer.style.top = '10px';
            elements.notificationContainer.style.right = '10px';
            elements.notificationContainer.style.zIndex = '9999';
            document.body.appendChild(elements.notificationContainer);
        }
    }

    /**
     * Start integrity monitoring
     */
    function start(examId, userId) {
        if (examId) examInfo.examId = examId;
        if (userId) examInfo.userId = userId;
        
        state.examStarted = true;
        localStorage.setItem('examStarted', 'true');
        localStorage.setItem('examRefreshCount', '0');
        
        setupEventListeners();
        startActivityPing();
        preventBackButton();
        enterFullscreen();
        
        updateUI();
        updateStatus('Exam integrity monitoring started');
    }

    /**
     * Stop integrity monitoring
     */
    function stop() {
        state.examStarted = false;
        localStorage.removeItem('examStarted');
        localStorage.removeItem('examRefreshCount');
        
        if (state.pingIntervalId) {
            clearInterval(state.pingIntervalId);
            state.pingIntervalId = null;
        }
        
        updateStatus('Exam integrity monitoring stopped');
    }

    /**
     * Setup event listeners for integrity monitoring
     */
    function setupEventListeners() {
        // Fullscreen change events
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Tab visibility and focus events
        document.addEventListener('visibilitychange', handleTabChange);
        window.addEventListener('blur', handleFocusChange);
        window.addEventListener('focus', handleFocusChange);
        
        // Mouse exit detection
        document.addEventListener('mouseout', handleMouseOut);
        
        // Copy/paste prevention
        document.addEventListener('copy', handleCopyAttempt);
        document.addEventListener('paste', handlePasteAttempt);
        if (!window.copyPasteControl) {
        document.addEventListener('copy', handleCopyAttempt);
        document.addEventListener('paste', handlePasteAttempt);
    }
        // Keyboard shortcuts prevention
        document.addEventListener('keydown', preventKeyboardShortcuts);
        
        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Window resize detection (potential DevTools)
        window.addEventListener('resize', handleResize);
        
        // Before unload warning
        window.addEventListener('beforeunload', handleBeforeUnload);
        
        // Ensure fullscreen on click
        document.addEventListener('click', () => {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                !document.mozFullScreenElement && !document.msFullscreenElement && 
                state.examStarted) {
                enterFullscreen();
                updateStatus("Fullscreen mode ensured after click");
            }
        });
    }

    /**
     * Prevent keyboard shortcuts
     */
    function preventKeyboardShortcuts(e) {
        if (!state.examStarted) return;
        
        // Prevent dev tools and refresh shortcuts
        if (e.key === 'F12' || 
            (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) || 
            (e.ctrlKey && e.key === 'U') ||
            e.key === 'F5' || 
            ((e.metaKey || e.ctrlKey) && e.key === 'r') ||
            e.key === 'F11' || 
            (e.metaKey && e.shiftKey && e.key === 'f') ||
            (e.altKey && e.key === 'Tab') ||
            (e.metaKey && e.key === 'w') || 
            (e.key === 'F4' && e.altKey)) {
            
            e.preventDefault();
            e.stopPropagation();
            showNotification("This action is not allowed during the exam.");
            return false;
        }
        
        // If Escape key is pressed, prevent default action and re-enter fullscreen
        if (e.key === 'Escape' && state.examStarted) {
            e.preventDefault();
            // Small delay to ensure the fullscreen exit completes first
            setTimeout(enterFullscreen, 100);
            return false;
        }
    }

    /**
     * Prevent back button
     */
    function preventBackButton() {
        window.history.pushState(null, "", window.location.href);
        window.onpopstate = function() {
            window.history.pushState(null, "", window.location.href);
        };
    }

    /**
     * Update UI with violation counts
     */
    function updateUI() {
        if (!state.examStarted) return;
        
        // Update DOM elements if they exist
        if (elements.tabChangeCount) elements.tabChangeCount.textContent = state.violations.tabChangeCount;
        if (elements.mouseOutCount) elements.mouseOutCount.textContent = state.violations.mouseOutCount;
        if (elements.fullscreenExitCount) elements.fullscreenExitCount.textContent = state.violations.fullscreenExitCount;
        if (elements.copyAttemptCount) elements.copyAttemptCount.textContent = state.violations.copyAttemptCount;
        if (elements.pasteAttemptCount) elements.pasteAttemptCount.textContent = state.violations.pasteAttemptCount;
        if (elements.focusChangeCount) elements.focusChangeCount.textContent = state.violations.focusChangeCount;
        if (elements.refreshViolationCount) elements.refreshViolationCount.textContent = state.violations.refreshViolationCount;
        if (elements.totalViolations) elements.totalViolations.textContent = state.totalViolations;
    }

    /**
     * Update status message
     */
    function updateStatus(message) {
        if (!state.examStarted) return;
        
        if (elements.lastEvent) {
            elements.lastEvent.textContent = message;
        }
        console.log('Integrity status:', message);
    }

    /**
     * Handle tab change events
     */
    function handleTabChange() {
        if (!state.examStarted) return;
        
        if (document.hidden) {
            // Only count tab change if it's not immediately after a focus change
            const currentTime = Date.now();
            if (currentTime - state.lastTabFocusTime > config.tabFocusCooldown) {
                state.violations.tabChangeCount++;
                state.totalViolations++;
                sendIntegrityUpdate("tabChanges");
                updateStatus("Tab change detected");
                updateUI();
                checkAndTriggerAutoSubmit();
            }
        }
    }

    /**
     * Handle mouse leaving the window
     */
    function handleMouseOut(event) {
        if (!state.examStarted) return;
        
        // Check if mouse actually left the window
        if (event.clientX < 0 || event.clientX > window.innerWidth - 1 || 
            event.clientY < 0 || event.clientY > window.innerHeight - 1) {
            state.violations.mouseOutCount++;
            state.totalViolations++;
            sendIntegrityUpdate("mouseOuts");
            updateStatus("Mouse left workspace");
            showNotification("Mouse Going Out is not allowed");
            updateUI();
            checkAndTriggerAutoSubmit();
        }
    }

    /**
     * Handle window focus changes
     */
    function handleFocusChange(event) {
        if (!state.examStarted) return;
        
        if (event.type === 'blur') {
            // Only count focus change if it's not immediately after a tab change
            const currentTime = Date.now();
            if (currentTime - state.lastTabFocusTime > config.tabFocusCooldown) {
                state.violations.focusChangeCount++;
                state.lastTabFocusTime = currentTime;
                
                // Check if this is coming from a tab change or standalone focus change
                if (!document.hidden) {
                    // If document is not hidden, this is a standalone focus change
                    state.totalViolations++;
                    sendIntegrityUpdate("focusChanges");
                    updateStatus("Focus change detected");
                    updateUI();
                    checkAndTriggerAutoSubmit();
                }
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    function handleFullscreenChange() {
        if (!state.examStarted) return;
        
        if (!document.fullscreenElement && !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && !document.msFullscreenElement) {
            state.violations.fullscreenExitCount++;
            state.totalViolations++;
            showNotification("Exiting fullscreen is not allowed during the exam.");
            
            // Give a short delay before forcing back to fullscreen (helps with Mac transition)
            setTimeout(enterFullscreen, 500);
            
            sendIntegrityUpdate("fullscreenExits");
            updateStatus("Fullscreen exited");
            updateUI();
            checkAndTriggerAutoSubmit();
        } else {
            if (!state.isFullscreenActive) {
                state.isFullscreenActive = true;
            }
            updateStatus("Fullscreen entered");
        }
    }

    /**
     * Enter fullscreen mode
     */
    function enterFullscreen() {
        const elem = document.documentElement;
        
        // Don't attempt to enter fullscreen if already in fullscreen mode
        if (document.fullscreenElement || document.webkitFullscreenElement || 
            document.mozFullScreenElement || document.msFullscreenElement) {
            return;
        }
        
        try {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) { // Firefox
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) { // IE/Edge
                elem.msRequestFullscreen();
            }
        } catch (error) {
            console.error("Fullscreen error:", error);
            showNotification("Fullscreen mode failed. Please try again.");
        }
    }

    /**
     * Handle copy attempts
     */
   // 1. Update the integrity monitoring copy/paste handlers
function handleCopyAttempt(e) {
    if (!state.examStarted) return;
    
    const target = e.target;
    const isCodeEditor = target.classList.contains('code-textarea') || 
                        target.id.startsWith('codeEditor-') ||
                        target.closest('.code-editor') !== null;
    
    if (!isCodeEditor) {
        // Only count violations for non-code-editor attempts
        state.violations.copyAttemptCount++;
        state.totalViolations++;
        sendIntegrityUpdate("copyAttempts");
        updateStatus("Copy attempt detected outside code editor");
        updateUI();
        checkAndTriggerAutoSubmit();
    }
}

function handlePasteAttempt(e) {
    if (!state.examStarted) return;
    
    const target = e.target;
    const isCodeEditor = target.classList.contains('code-textarea') || 
                        target.id.startsWith('codeEditor-') ||
                        target.closest('.code-editor') !== null;
    
    if (!isCodeEditor) {
        // Only count violations for non-code-editor attempts
        state.violations.pasteAttemptCount++;
        state.totalViolations++;
        sendIntegrityUpdate("pasteAttempts");
        updateStatus("Paste attempt detected outside code editor");
        updateUI();
        checkAndTriggerAutoSubmit();
    }
}


    /**
     * Handle resize events (potential DevTools)
     */
    function handleResize() {
        if (!state.examStarted) return;
        
        const currentTime = Date.now();
        
        // Check if we're within the cooldown period
        if (currentTime - state.lastResizeTime < config.resizeCooldown) {
            // Count this as another attempt within the same period
            state.resizeAttempts++;
            
            // Check if max attempts exceeded
            if (state.resizeAttempts >= config.maxResizeAttempts) {
                // Only show notification and count as violation if not due to Mac-specific events
                if (Math.abs(window.innerHeight - window.screen.height) > 100) {
                    showNotification(`DevTools detected! Your exam is being monitored.`, 'error');
                    state.totalViolations++;
                    sendIntegrityUpdate("resizeViolations");
                    updateStatus("Multiple suspicious resize events detected");
                    updateUI();
                    
                    // Show the violation modal and trigger auto-submit
                    showViolationModal(() => {
                        if (state.autoSubmitCallback) {
                            state.autoSubmitCallback("resize_violations");
                        }
                    });
                }
            }
        } else {
            // First resize attempt in a new period
            state.resizeAttempts = 1;
            
            if (state.resizeAttempts > 1) {
                showNotification(`Window resize detected. This is being monitored.`);
            }
        }
        
        // Update the timestamp
        state.lastResizeTime = currentTime;
        
        // Check if total violations are too high
        checkAndTriggerAutoSubmit();
    }

    /**
     * Handle beforeunload event
     */
    function handleBeforeUnload(e) {
        if (!state.examStarted) return;
        
        if (state.pingIntervalId) {
            clearInterval(state.pingIntervalId);
            
            // Send final ping with status=inactive
            fetch(apiEndpoints.activityPing, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    examId: examInfo.examId,
                    userId: examInfo.userId,
                    timestamp: new Date().toISOString(),
                    status: 'inactive'
                }),
                keepalive: true
            });
        }
        
        if (state.submitting) {
            return;
        }
        
        e.preventDefault();
        e.returnValue = '';
        return '';
    }

    /**
     * Handle refresh detection
     */
    function handleRefreshDetection() {
        // Check if there's a saved refresh count
        let refreshCount = parseInt(localStorage.getItem('examRefreshCount') || '0');
        
        if (state.examStarted) {
            refreshCount++;
            localStorage.setItem('examRefreshCount', refreshCount.toString());
        }
        
        // Count this as a violation if it's not the first load
        if (refreshCount > 1) {
            state.violations.refreshViolationCount = refreshCount - 1; // Don't count the initial load
            state.totalViolations += 1; // Increment total violations by 1 for this refresh
            
            // Send refresh event to server for logging
            sendIntegrityUpdate("pageRefresh");
            updateStatus("Page refresh detected");
            updateUI();
            
            // Check if exceeded maximum allowed refreshes
            if (refreshCount > config.maxRefreshes) {
                showNotification(`Maximum page refreshes (${config.maxRefreshes}) exceeded. Your exam is being submitted.`, 'error');
                
                if (state.autoSubmitCallback) {
                    state.autoSubmitCallback("excessive_refreshes");
                }
                
                return false;
            }
        }
        
        return true;
    }

    /**
     * Check and trigger auto-submit if violations are too high
     */
    function checkAndTriggerAutoSubmit() {
        if (!state.examStarted) return;
        
        if (state.totalViolations >= config.maxViolations) {
            updateStatus("Auto-submitting test due to integrity violations");
            const modalOverlay = showViolationModal(() => {
                if (state.autoSubmitCallback) {
                    state.autoSubmitCallback("integrity_violations");
                }
            });
        }
    }

    /**
     * Show violation modal
     */
    function showViolationModal(callback) {
        // Create modal container
        const modalOverlay = document.createElement('div');
        modalOverlay.style.position = 'fixed';
        modalOverlay.style.top = '0';
        modalOverlay.style.left = '0';
        modalOverlay.style.width = '100%';
        modalOverlay.style.height = '100%';
        modalOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        modalOverlay.style.display = 'flex';
        modalOverlay.style.justifyContent = 'center';
        modalOverlay.style.alignItems = 'center';
        modalOverlay.style.zIndex = '10000';
        
        // Create modal content
        const modalContent = document.createElement('div');
        modalContent.style.backgroundColor = '#fff';
        modalContent.style.padding = '25px';
        modalContent.style.borderRadius = '10px';
        modalContent.style.maxWidth = '500px';
        modalContent.style.width = '80%';
        modalContent.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.3)';
        modalContent.style.textAlign = 'center';
        
        // Add warning icon
        const warningIcon = document.createElement('div');
        warningIcon.innerHTML = '⚠️';
        warningIcon.style.fontSize = '4rem';
        warningIcon.style.marginBottom = '15px';
        modalContent.appendChild(warningIcon);
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = 'Critical Violation Alert';
        title.style.color = '#d9534f';
        title.style.marginBottom = '15px';
        modalContent.appendChild(title);
        
        // Add message
        const message = document.createElement('p');
        message.textContent = `You have committed ${state.totalViolations} or more integrity violations. Your exam will be automatically submitted.`;
        message.style.marginBottom = '20px';
        message.style.fontSize = '1.1rem';
        message.style.color = '#000';
        modalContent.appendChild(message);
        
        // Add violations list
        const violationsList = document.createElement('div');
        violationsList.style.textAlign = 'left';
        violationsList.style.marginBottom = '20px';
        violationsList.style.padding = '10px';
        violationsList.style.backgroundColor = '#f8d7da';
        violationsList.style.borderRadius = '5px';
        violationsList.style.color = '#000';
        
        let violationsHTML = '<strong>Violations detected:</strong><ul style="margin-top: 10px;">';
        
        // Add each violation type with count
        if (state.violations.tabChangeCount > 0) violationsHTML += `<li>Tab changes: ${state.violations.tabChangeCount}</li>`;
        if (state.violations.mouseOutCount > 0) violationsHTML += `<li>Mouse left window: ${state.violations.mouseOutCount}</li>`;
        if (state.violations.fullscreenExitCount > 0) violationsHTML += `<li>Fullscreen exits: ${state.violations.fullscreenExitCount}</li>`;
        if (state.violations.copyAttemptCount > 0) violationsHTML += `<li>Copy attempts: ${state.violations.copyAttemptCount}</li>`;
        if (state.violations.pasteAttemptCount > 0) violationsHTML += `<li>Paste attempts: ${state.violations.pasteAttemptCount}</li>`;
        if (state.violations.focusChangeCount > 0) violationsHTML += `<li>Focus changes: ${state.violations.focusChangeCount}</li>`;
        if (state.violations.refreshViolationCount > 0) violationsHTML += `<li>Page refreshes: ${state.violations.refreshViolationCount}</li>`;
        
        violationsHTML += '</ul>';
        violationsList.innerHTML = violationsHTML;
        modalContent.appendChild(violationsList);
        
        // Add countdown text
        const countdown = document.createElement('p');
        countdown.textContent = 'Submitting exam in 5 seconds...';
        countdown.style.fontWeight = 'bold';
        countdown.style.color = '#000';
        modalContent.appendChild(countdown);
        
        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);
        
        // Start countdown
        let seconds = 5;
        const countdownInterval = setInterval(() => {
            seconds--;
            countdown.textContent = `Submitting exam in ${seconds} second${seconds !== 1 ? 's' : ''}...`;
            
            if (seconds <= 0) {
                clearInterval(countdownInterval);
                if (callback && typeof callback === 'function') {
                    callback();
                }
            }
        }, 1000);
        
        return modalOverlay;
    }

    /**
     * Show notification
     */
    function showNotification(message, type = 'warning') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.style.backgroundColor = type === 'warning' ? '#fff3cd' : '#f8d7da';
        notification.style.color = type === 'warning' ? '#856404' : '#721c24';
        notification.style.padding = '10px 15px';
        notification.style.marginBottom = '10px';
        notification.style.borderRadius = '4px';
        notification.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
        notification.style.width = '300px';
        notification.style.animation = 'fadeIn 0.3s ease-out';
        notification.innerHTML = message;
        
        // Add to container
        elements.notificationContainer.appendChild(notification);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            notification.style.animation = 'fadeOut 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 5000);
        
        return notification;
    }

    /**
     * Send integrity update to server
     */
    function sendIntegrityUpdate(eventType) {
        if (!state.examStarted) return;
        
        const data = {
            examId: examInfo.examId,
            userId: examInfo.userId,
            eventType: eventType
        };

        fetch(apiEndpoints.integrityUpdate, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => console.log('Integrity event logged:', data))
        .catch(error => console.error('Error sending integrity update:', error));
    }

    /**
     * Start sending activity pings to server
     */
    function startActivityPing() {
        if (state.pingIntervalId) {
            clearInterval(state.pingIntervalId);
        }
        
        // Send initial ping
        sendActivityPing();
        
        // Set up interval for regular pings
        state.pingIntervalId = setInterval(sendActivityPing, config.pingInterval);
    }

    /**
     * Send activity ping to server
     */
    function sendActivityPing() {
        if (!state.examStarted) return;
        
        fetch(apiEndpoints.activityPing, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                examId: examInfo.examId,
                userId: examInfo.userId,
                timestamp: new Date().toISOString()
            })
        })
        .then(response => {
            if (!response.ok) {
                console.error('Failed to send activity ping');
            }
        })
        .catch(error => {
            console.error('Error sending activity ping:', error);
        });
    }

    /**
     * Start webcam capture
     */
    function startWebcamCapture() {
        const canvas = document.createElement('canvas');
        canvas.width = 320;
        canvas.height = 240;
        canvas.style.display = 'none';
        document.body.appendChild(canvas);
        
        const context = canvas.getContext('2d');
        
        // Check if media devices API is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.error("MediaDevices API not supported");
            showNotification("Your browser doesn't support webcam capture. Please use a modern browser.", 'error');
            return;
        }

        navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 320 },
                height: { ideal: 240 },
                facingMode: "user"
            } 
        })
        .then((stream) => {
            const video = document.createElement('video');
            video.srcObject = stream;
            video.style.display = 'none';
            document.body.appendChild(video);
            video.play();
            
            // Wait for video to be ready
            video.onloadedmetadata = () => {
                // Set up snapshot interval
                setInterval(() => {
                    try {
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        canvas.toBlob((blob) => {
                            if (!blob) return;
                            
                            const formData = new FormData();
                            formData.append('image', blob, `capture-${Date.now()}.png`);
                            formData.append('userId', examInfo.userId);
                            formData.append('examId', examInfo.examId);
                            
                            fetch(apiEndpoints.saveImage, { 
                                method: 'POST',
                                body: formData,
                            })
                            .then(response => response.json())
                            .then(data => console.log('Image saved:', data))
                            .catch(error => console.error('Error saving image:', error));
                        }, 'image/png');
                    } catch (err) {
                        console.error("Error capturing webcam frame:", err);
                    }
                }, config.webcamCaptureInterval);
            };
        })
        .catch((error) => {
            console.error("Error accessing webcam:", error);
            showNotification("Unable to access the webcam. Please ensure your camera is connected and you've allowed permission.", 'error');
        });
    }

    /**
     * Get current violation counts
     */
    function getViolationCounts() {
        return {
            ...state.violations,
            totalViolations: state.totalViolations
        };
    }

    // Return public API
    return {
        init,
        start,
        stop,
        enterFullscreen,
        handleRefreshDetection,
        startWebcamCapture,
        showNotification,
        getViolationCounts,
        preventBackButton
    };
})();

</script>


    <script>
    // Judge0 API base URL
    

    // Store the exam data in localStorage when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        // Assuming 'exam' is passed from the server to the EJS template
        const examData = <%- JSON.stringify(exam) %>;
          const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
             if (mainContainer && header) {
        mainContainer.style.display = 'none';
        header.style.display = 'none';
        
        // Create start exam overlay
        const startOverlay = document.createElement('div');
        startOverlay.className = 'start-exam-overlay';
        startOverlay.innerHTML = `
            <div class="start-exam-container">
                <div class="start-exam-header">
                    <div class="header-logo">
                        <i class="fas fa-graduation-cap"></i> Exam Portal
                    </div>
                </div>
                <div class="start-exam-content">
                    <div class="start-exam-title" id="examTitleStart">Loading exam...</div>
                    <div class="start-exam-info">
                        <div class="info-item">
                            <i class="fas fa-clock"></i>
                            <span id="examDurationStart">-- minutes</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-tasks"></i>
                            <span id="examTypeStart">--</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-info-circle"></i>
                            <span id="examQuestionsStart">-- questions</span>
                        </div>
                    </div>
                    <div class="start-exam-instructions">
                        <h3><i class="fas fa-list-ul"></i> Instructions</h3>
                        <ul>
                            <li>The timer will start as soon as you begin the exam.</li>
                            <li>Answer all questions to the best of your ability.</li>
                            <li>You can navigate between questions using the side panel.</li>
                            <li>Submit your exam when you're finished.</li>
                            <li>Don't refresh or leave the page during the exam.</li>
                        </ul>
                    </div>
                    <div class="start-button-container">
                        <button id="startExamButton" class="start-exam-button">
                            <i class="fas fa-play"></i> Start Exam
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(startOverlay);

    const userId = document.getElementById('user').textContent;
    const examId = document.getElementById('exam').textContent;
    
    // Initialize the module with configuration
    const integrity = examIntegrity.init({
        // Required exam information
        examId: examId,
        userId: userId,
        
        // Optional: Custom API endpoints
        apiEndpoints: {
            integrityUpdate: '/update-integrity',
            activityPing: '/dashboard/see-active',
            saveImage: '/save-image'
        },
        
        // Optional: Custom behavior configuration
        config: {
            maxViolations: 5,                // Default: 3
            maxRefreshes: 3,                 // Default: 2
            pingInterval: 30000,             // Default: 20000 (20 seconds)
            webcamCaptureInterval: 10000     // Default: 5000 (5 seconds)
        },
        
        // Optional: Callback when violations trigger auto-submit
        onAutoSubmit: function(reason) {
            console.log(`Auto-submitting exam due to: ${reason}`);
            
            // Your custom submit logic
            submitExam()
            
            // Optional: Redirect after submission

        },
        
        // Optional: Start webcam automatically on init
        startWebcam: false
    });
    
    // Start monitoring when the exam begins
  
    // Example: Submit exam button

        
        // Get exam data and update the title
if (examData) {
            document.getElementById('examTitleStart').textContent = examData.name;
            document.getElementById('examDurationStart').textContent = `${examData.duration} minutes`;
            
            // Display exam type
            let examType = '';
            if (examData.questionType === "mcq") {
                examType = 'Multiple Choice';
            } else if (examData.questionType === "coding") {
                examType = 'Coding';
            } else if (examData.questionType === "mcq&coding") {
                examType = 'Mixed (MCQ & Coding)';
            }
            document.getElementById('examTypeStart').textContent = examType;
            
            // Display question count
            let totalQuestions = getTotalQuestions(examData);
            document.getElementById('examQuestionsStart').textContent = `${totalQuestions} questions`;
        }
        
        // Add event listener to start exam button
        document.getElementById('startExamButton').addEventListener('click', startExam);
    }



    function startExam() {
    // Remove the overlay
    const startOverlay = document.querySelector('.start-exam-overlay');
    if (startOverlay) {
        startOverlay.remove();
    }
       if (window.copyPasteControl) {
        window.copyPasteControl.start();
        console.log('Copy-paste control started');
    }
    // Show the main content
    const mainContainer = document.querySelector('.main-container');
    const header = document.querySelector('.header');
    
    if (mainContainer && header) {
        mainContainer.style.display = 'grid';
        header.style.display = 'flex';
    }
    
    // Initialize the exam
    initializeExam();
    
    // Start the timer
    const endTime = new Date().getTime() + (JSON.parse(localStorage.getItem('currentExam')).duration * 60 * 1000);
    localStorage.setItem('examEndTime', endTime.toString());

       const userId = document.getElementById('user').textContent;
    const examId = document.getElementById('exam').textContent;
    
    // Initialize the module with configuration
    const integrity = examIntegrity.init({
        // Required exam information
        examId: examId,
        userId: userId,
        
        // Optional: Custom API endpoints
        apiEndpoints: {
            integrityUpdate: '/update-integrity',
            activityPing: '/dashboard/see-active',
            saveImage: '/save-image'
        },
        
        // Optional: Custom behavior configuration
        config: {
            maxViolations: 999,                // Default: 3
            maxRefreshes: 999,                 // Default: 2
            pingInterval: 30000,             // Default: 20000 (20 seconds)
            webcamCaptureInterval: 10000     // Default: 5000 (5 seconds)
        },
        
        // Optional: Callback when violations trigger auto-submit
        onAutoSubmit: function(reason) {
            console.log(`Auto-submitting exam due to: ${reason}`);
            
            // Your custom submit logic
            submitExam()
            
            // Optional: Redirect after submission

        },
        
        // Optional: Start webcam automatically on init
        startWebcam: false
    });
    
        // Start the integrity monitoringsss
        integrity.start();
        
        // Start webcam capture if not auto-started
        if(document.getElementById('camneed').innerHTML == "true") {
            integrity.startWebcamCapture();
        }
        
        
        // Enter fullscreen mode
        integrity.enterFullscreen();
        
        // Prevent back button navigation
        integrity.preventBackButton();
        
        // Show example notification
        integrity.showNotification('Exam has started. Integrity monitoring is active.');
        
        // Hide the start button and show exam content
        this.style.display = 'none';
        document.getElementById('examContent').style.display = 'block';

    
    startExamTimer();
}
const startExamStyles = `
    .start-exam-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #f3f4f6;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        padding: 1rem;
    }

    body.dark-theme .start-exam-overlay {
        background-color: #1e1e2d;
    }

    .start-exam-container {
        max-width: 800px;
        width: 100%;
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg);
        overflow: hidden;
        background-color: var(--white);
        animation: slideUp 0.5s ease;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    body.dark-theme .start-exam-container {
        background-color: #252636;
        color: #e5e7eb;
    }

    .start-exam-header {
        background-color: var(--primary);
        color: var(--white);
        padding: 1rem 1.5rem;
        display: flex;
        align-items: center;
    }

    .start-exam-content {
        padding: 2rem;
    }

    .start-exam-title {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 1.5rem;
        color: var(--dark);
        text-align: center;
    }

    body.dark-theme .start-exam-title {
        color: #e5e7eb;
    }

    .start-exam-info {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 2rem;
        margin-bottom: 2rem;
        padding: 1rem;
        background-color: #f8fafc;
        border-radius: var(--border-radius);
    }

    body.dark-theme .start-exam-info {
        background-color: #2d2d3f;
    }

    .info-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .info-item i {
        color: var(--primary);
        font-size: 1.25rem;
    }

    .start-exam-instructions {
        margin-bottom: 2rem;
        padding: 1.5rem;
        background-color: #f8fafc;
        border-radius: var(--border-radius);
        border-left: 4px solid var(--primary);
    }

    body.dark-theme .start-exam-instructions {
        background-color: #2d2d3f;
    }

    .start-exam-instructions h3 {
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--primary);
    }

    .start-exam-instructions ul {
        list-style-type: none;
        padding-left: 1.5rem;
    }

    .start-exam-instructions li {
        margin-bottom: 0.5rem;
        position: relative;
    }

    .start-exam-instructions li:before {
        content: "•";
        color: var(--primary);
        font-weight: bold;
        display: inline-block;
        width: 1rem;
        position: absolute;
        left: -1rem;
    }

    .start-button-container {
        display: flex;
        justify-content: center;
    }

    .start-exam-button {
        padding: 1rem 3rem;
        font-size: 1.25rem;
        background-color: var(--success);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
    }

    .start-exam-button:hover {
        background-color: #059669;
        transform: translateY(-2px);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    }

    .start-exam-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    @media (max-width: 768px) {
        .start-exam-info {
            flex-direction: column;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .start-exam-title {
            font-size: 1.5rem;
        }
        
        .start-exam-button {
            padding: 0.75rem 2rem;
            font-size: 1.1rem;
        }
    }
`;

// Append the styles to the document
const styleElement = document.createElement('style');
styleElement.textContent += startExamStyles;
document.head.appendChild(styleElement);
        // Store the entire exam object
        localStorage.setItem('currentExam', JSON.stringify(examData));
        
        // Store questions separately for easier access
        if (examData.questionType === "mcq") {
            localStorage.setItem('mcqQuestions', JSON.stringify(examData.mcqQuestions));
        } else if (examData.questionType === "coding") {
            localStorage.setItem('codingQuestions', JSON.stringify(examData.codingQuestions));
        } else if (examData.questionType === "mcq&coding") {
            localStorage.setItem('mcqQuestions', JSON.stringify(examData.mcqQuestions));
            localStorage.setItem('codingQuestions', JSON.stringify(examData.codingQuestions));
        }
        
        // Initialize current question index
        localStorage.setItem('currentQuestionIndex', '0');
        
        // Initialize timer if exam has duration
        if (examData.duration) {
            const endTime = new Date().getTime() + (examData.duration * 60 * 1000);
            localStorage.setItem('examEndTime', endTime.toString());
        }
        
        // Initialize empty answers object
        const emptyAnswers = {
            mcq: {},
            coding: {}
        };
        localStorage.setItem('examAnswers', JSON.stringify(emptyAnswers));
        
        // Set up dark mode toggle
        setupDarkModeToggle();
        
        // Trigger the exam initialization
        initializeExam();
    });

    // Function to set up dark mode toggle
    function setupDarkModeToggle() {
        const darkModeToggle = document.getElementById('darkModeToggle');
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
        
        // Check if user has a preference stored
        const currentTheme = localStorage.getItem('theme');
        if (currentTheme === 'dark') {
            document.body.classList.add('dark-theme');
            darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        } else if (currentTheme === 'light') {
            document.body.classList.remove('dark-theme');
            document.body.
            darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        } else if (prefersDarkScheme.matches) {
            document.body.classList.add('dark-theme');
            darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        }
        
        darkModeToggle.addEventListener('click', () => {
            if (document.body.classList.contains('dark-theme')) {
                document.body.classList.remove('dark-theme');
                darkModeToggle.innerHTML = '<i class="fas fa-moon"></i>';
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.add('dark-theme');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i>';
                localStorage.setItem('theme', 'dark');
            }
        });
    }

    // Function to handle exam initialization
    function initializeExam() {
        // Get the exam data from localStorage
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
        
        // Display exam information
        document.getElementById('examTitle').textContent = examData.name;
        document.getElementById('examDuration').textContent = `${examData.duration} minutes`;
        
        // Display exam type
        let examType = '';
        if (examData.questionType === "mcq") {
            examType = 'Multiple Choice';
        } else if (examData.questionType === "coding") {
            examType = 'Coding';
        } else if (examData.questionType === "mcq&coding") {
            examType = 'Mixed (MCQ & Coding)';
        }
        document.getElementById('examType').textContent = examType;
        
        // Determine which question to load first
        loadQuestion(currentIndex);
        
        // Start the timer
        startExamTimer();
        
        // Set up navigation between questions
        setupQuestionNavigation();

        // Set up keyboard shortcuts
        setupKeyboardShortcuts();
        
        // Set up auto-save
        setupAutoSave();
        
        // Update progress indicators
        updateProgress();
    }

    // Function to set up keyboard shortcuts
    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // Ctrl+Enter to submit exam
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                confirmSubmitExam();
                e.preventDefault();
            }
            
            // Left arrow for previous question
            if (e.altKey && e.key === 'ArrowLeft') {
                const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex'));
                if (currentIndex > 0) {
                    loadQuestion(currentIndex - 1);
                }
                e.preventDefault();
            }
            
            // Right arrow for next question
            if (e.altKey && e.key === 'ArrowRight') {
                const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex'));
                const examData = JSON.parse(localStorage.getItem('currentExam'));
                let totalQuestions = getTotalQuestions(examData);
                
                if (currentIndex < totalQuestions - 1) {
                    loadQuestion(currentIndex + 1);
                }
                e.preventDefault();
            }
        });
    }

    // Helper function to get total questions
function getTotalQuestions(examData) {
    if (!examData) {
        console.error('No exam data provided to getTotalQuestions');
        return 0;
    }
    
    let total = 0;
    
    if (examData.questionType === "mcq") {
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions')) || [];
        total = mcqQuestions.length; // Use actual array length instead of examData.numMCQs
    } else if (examData.questionType === "coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
        total = codingQuestions.length; // Use actual array length instead of examData.numCoding
    } else if (examData.questionType === "mcq&coding") {
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions')) || [];
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
        total = mcqQuestions.length + codingQuestions.length; // Calculate from actual arrays
    }
    
    console.log(`Total questions calculated: ${total} for type: ${examData.questionType}`); // Debug log
    return total;
}

    // Function to set up auto-save
    function setupAutoSave() {
        setInterval(() => {
            const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
            const examData = JSON.parse(localStorage.getItem('currentExam'));
            
            if (!examData) return; // Exit if no exam data
            
            if (examData.questionType === "mcq" || examData.questionType === "mcq&coding") {
                // For MCQs, get all radio buttons for the current question
                const mcqRadios = document.querySelectorAll(`input[name="q${currentIndex}"]`);
                mcqRadios.forEach(radio => {
                    if (radio.checked) {
                        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
                        const question = mcqQuestions[currentIndex];
                        if (question) {
                            const optionIndex = parseInt(radio.value);
                            const optionText = question.options[optionIndex];
                            saveMCQAnswer(question._id, optionIndex, optionText);
                        }
                    }
                });
            }
            
            if (examData.questionType === "coding" || examData.questionType === "mcq&coding") {
                // For coding questions, get the code editor value
                const mcqLength = examData.questionType === "mcq&coding" ? 
                    examData.numMCQs : 0;
                
                if (currentIndex >= mcqLength) {
                    const codingIndex = currentIndex - mcqLength;
                    const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
                    const question = codingQuestions[codingIndex];
                    
                    if (question) {
                        const codeEditor = document.getElementById(`codeEditor-${question._id}`);
                        if (codeEditor) {
                            saveCodingAnswer(question._id, codeEditor.value);
                        }
                    }
                }
            }
            
            // Update progress after auto-save
            updateProgress();
        }, 10000); // Auto-save every 10 seconds
    }

    // Function to update progress indicators
    function updateProgress() {
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        
        // Count answered questions
        let answeredCount = 0;
        let totalQuestions = getTotalQuestions(examData);
        
        // Count MCQ answers
        if (answers.mcq) {
            answeredCount += Object.keys(answers.mcq).length;
        }
        
        // Count coding answers
        if (answers.coding) {
            // Only count non-empty coding answers
            for (const questionId in answers.coding) {
                if (answers.coding[questionId] && answers.coding[questionId].trim() !== '') {
                    const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
                    const question = codingQuestions.find(q => q._id === questionId);
                    
                    // Check if the answer is not just the starter code
                    if (question && !isStarterCode(answers.coding[questionId], question)) {
                        answeredCount++;
                    }
                }
            }
        }
        
        // Update progress bar and stats
        const progressPercent = totalQuestions > 0 ? (answeredCount / totalQuestions) * 100 : 0;
        document.getElementById('progressFill').style.width = `${progressPercent}%`;
        document.getElementById('answeredQuestions').textContent = `${answeredCount} answered`;
        document.getElementById('totalQuestions').textContent = `${totalQuestions} total`;
    }

    // Function to load a specific question
 
function loadQuestion(index) {
    console.log(`Loading question at index: ${index}`); // Debug log
    
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    if (!examData) {
        console.error('No exam data found');
        return;
    }
    
    let question;
    let questionType;
    let totalQuestions = getTotalQuestions(examData);
    
    // Validate index
    if (index < 0 || index >= totalQuestions) {
        console.error(`Invalid question index: ${index}. Total questions: ${totalQuestions}`);
        return;
    }
    
    // Get the appropriate question based on question type and index
    if (examData.questionType === "mcq") {
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
        if (!mcqQuestions || index >= mcqQuestions.length) {
            console.error(`MCQ question not found at index: ${index}`);
            return;
        }
        question = mcqQuestions[index];
        questionType = "mcq";
    } 
    else if (examData.questionType === "coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
        if (!codingQuestions || index >= codingQuestions.length) {
            console.error(`Coding question not found at index: ${index}`);
            return;
        }
        question = codingQuestions[index];
        questionType = "coding";
    } 
    else if (examData.questionType === "mcq&coding") {
        // For mixed exams, determine if we're showing MCQ or coding based on index
        const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions')) || [];
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
        
        console.log(`Mixed exam: MCQ count: ${mcqQuestions.length}, Coding count: ${codingQuestions.length}, Index: ${index}`); // Debug log
        
        if (index < mcqQuestions.length) {
            question = mcqQuestions[index];
            questionType = "mcq";
        } else {
            const codingIndex = index - mcqQuestions.length;
            if (codingIndex >= codingQuestions.length) {
                console.error(`Coding question not found at adjusted index: ${codingIndex}`);
                return;
            }
            question = codingQuestions[codingIndex];
            questionType = "coding";
        }
    }
    
    if (!question) {
        console.error(`Question not found at index: ${index}`);
        return;
    }
    
    console.log(`Question loaded: ${question._id}, Type: ${questionType}`); // Debug log
    
    // Update the current question index BEFORE displaying the question
    localStorage.setItem('currentQuestionIndex', index.toString());
    
    // Update question number display
    const questionNumberElement = document.getElementById('questionNumber');
    if (questionNumberElement) {
        questionNumberElement.textContent = `Question ${index + 1}`;
    }
    
    // Display the question based on type
    if (questionType === "mcq") {
        displayMCQQuestion(question, index);
    } else {
        displayCodingQuestion(question, index);
    }
    
    // Update the question navigation UI
    updateQuestionNavigation(index);
}

    // Function to display an MCQ question
    function displayMCQQuestion(question, index) {
    const questionContainer = document.getElementById('questionContainer');
    questionContainer.innerHTML = ''; // Clear previous content
    
    // Create question display
    const questionElement = document.createElement('div');
    questionElement.classList.add('mcq-question');
    
    // Add question title and text
    const questionTitle = document.createElement('h2');
    questionTitle.classList.add('question-title');
    
    // ✅ UPDATED: Better approach for handling code formatting
    const questionText = question.questionTitle || question.question;
    
    // Check if question contains code
    if (questionText.includes('CODE:')) {
        const parts = questionText.split('CODE:');
        const questionPart = parts[0].trim().replace(/\\n$/, '').replace(/\n$/, '');
        const codePart = parts[1].trim();
        
        // Set the question part as text
        questionTitle.textContent = questionPart;
        
        // ✅ NEW: Create code block element separately to avoid HTML escaping issues
        const codeBlock = document.createElement('div');
        codeBlock.classList.add('code-block');
        
        // ✅ FIX: Use textContent to automatically handle HTML characters correctly
        const formattedCode = codePart
            .replace(/\\n/g, '\n')  // Convert \\n to actual newlines
            .replace(/\t/g, '    '); // Convert tabs to 4 spaces
        
        codeBlock.textContent = formattedCode;
        
        // Add both elements to the question
        questionElement.appendChild(questionTitle);
        questionElement.appendChild(codeBlock);
    } else {
        // ✅ FALLBACK: Handle non-code questions
        const formattedQuestion = formatQuestionText(questionText);
        questionTitle.innerHTML = formattedQuestion;
        questionElement.appendChild(questionTitle);
    }
    
    // ✅ CHANGED: Add specific class for code formatting
    questionTitle.classList.add('question-with-code');
    
    // Add options (unchanged - works perfectly)
    const optionsContainer = document.createElement('div');
    optionsContainer.classList.add('mcq-options');
    
    question.options.forEach((option, i) => {
        const optionDiv = document.createElement('div');
        optionDiv.classList.add('mcq-option');
        
        // Check if this option is already selected
        const isSelected = getSelectedMCQAnswer(question._id, i);
        if (isSelected) {
            optionDiv.classList.add('selected');
        }
        
        // Create radio input
        const radioInput = document.createElement('input');
        radioInput.type = 'radio';
        radioInput.name = `q${index}`;
        radioInput.id = `q${index}opt${i}`;
        radioInput.value = i;
        radioInput.checked = isSelected;
        
        // Create label
        const label = document.createElement('label');
        label.htmlFor = `q${index}opt${i}`;
        label.textContent = option;
        
        // Add event listener to save answer and update UI
        radioInput.addEventListener('change', () => {
            // Save the selected answer
            saveMCQAnswer(question._id, i, option);
            
            // Update the UI
            optionsContainer.querySelectorAll('.mcq-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            optionDiv.classList.add('selected');
            
            // Update progress
            updateProgress();
        });
        
        // Also add click event to the whole option div for better UX
        optionDiv.addEventListener('click', () => {
            radioInput.checked = true;
            
            // Trigger the change event
            const event = new Event('change');
            radioInput.dispatchEvent(event);
        });
        
        // Append elements
        optionDiv.appendChild(radioInput);
        optionDiv.appendChild(label);
        optionsContainer.appendChild(optionDiv);
    });
    
    questionElement.appendChild(optionsContainer);
    questionContainer.appendChild(questionElement);
    
    // Clear any badges from previous questions
    document.getElementById('questionBadges').innerHTML = '';
}

    // Function to display a coding question
    function displayCodingQuestion(question, index) {
        const questionContainer = document.getElementById('questionContainer');
        questionContainer.innerHTML = ''; // Clear previous content
        
        // Add badges to the question header
        const badgesContainer = document.getElementById('questionBadges');
        badgesContainer.innerHTML = '';
        
        if (question.level) {
            const levelBadge = document.createElement('div');
            levelBadge.className = `badge badge-${question.level}`;
            levelBadge.textContent = question.level.toUpperCase();
            badgesContainer.appendChild(levelBadge);
        }
        
        if (question.classification) {
            const categoryBadge = document.createElement('div');
            categoryBadge.className = 'badge badge-category';
            categoryBadge.textContent = question.classification;
            badgesContainer.appendChild(categoryBadge);
        }
        
        if (question.maxMarks) {
            const marksBadge = document.createElement('div');
            marksBadge.className = 'badge badge-marks';
            marksBadge.textContent = `${question.maxMarks} marks`;
            badgesContainer.appendChild(marksBadge);
        }
        
        // Create question display with additional test case elements
        const questionElement = document.createElement('div');
        questionElement.classList.add('coding-question');
        
        // Add question title
        const questionTitle = document.createElement('h2');
        questionTitle.classList.add('question-title');
        questionTitle.textContent = question.questionTile || `Problem ${index + 1}`;
        questionElement.appendChild(questionTitle);
        
        // Add question description
        const questionDescription = document.createElement('div');
        questionDescription.classList.add('question-description');
        questionDescription.innerHTML = question.questiontext;
        questionElement.appendChild(questionDescription);
        
        // Add input format if available
        if (question.inputFormat) {
            const inputFormatTitle = document.createElement('h3');
            inputFormatTitle.classList.add('section-title');
            inputFormatTitle.innerHTML = '<i class="fas fa-sign-in-alt"></i> Input Format';
            questionElement.appendChild(inputFormatTitle);
            
            const inputFormat = document.createElement('p');
            inputFormat.innerHTML = question.inputFormat;
            questionElement.appendChild(inputFormat);
        }
        
        // Add output format if available
        if (question.outputFormat) {
            const outputFormatTitle = document.createElement('h3');
            outputFormatTitle.classList.add('section-title');
            outputFormatTitle.innerHTML = '<i class="fas fa-sign-out-alt"></i> Output Format';
            questionElement.appendChild(outputFormatTitle);
            
            const outputFormat = document.createElement('p');
            outputFormat.innerHTML = question.outputFormat;
            questionElement.appendChild(outputFormat);
        }
        
        // Add constraints if available
        if (question.constraits) {
            const constraintsTitle = document.createElement('h3');
            constraintsTitle.classList.add('section-title');
            constraintsTitle.innerHTML = '<i class="fas fa-exclamation-circle"></i> Constraints';
            questionElement.appendChild(constraintsTitle);
            
            const constraints = document.createElement('p');
            constraints.innerHTML = question.constraits;
            questionElement.appendChild(constraints);
        }
        
        // Add sample input/output if available
        if (question.sampleInput || question.sampleOutput) {
            const sampleTitle = document.createElement('h3');
            sampleTitle.classList.add('section-title');
            sampleTitle.innerHTML = '<i class="fas fa-vial"></i> Sample Test Case';
            questionElement.appendChild(sampleTitle);
            
            if (question.sampleInput) {
                const sampleInputTitle = document.createElement('h4');
                sampleInputTitle.textContent = 'Sample Input:';
                sampleInputTitle.style.fontWeight = '600';
                sampleInputTitle.style.marginTop = '0.75rem';
                questionElement.appendChild(sampleInputTitle);
                
                const sampleInput = document.createElement('pre');
                sampleInput.textContent = question.sampleInput;
                questionElement.appendChild(sampleInput);
            }
            
            if (question.sampleOutput) {
                const sampleOutputTitle = document.createElement('h4');
                sampleOutputTitle.textContent = 'Sample Output:';
                sampleOutputTitle.style.fontWeight = '600';
                sampleOutputTitle.style.marginTop = '0.75rem';
                questionElement.appendChild(sampleOutputTitle);
                
                const sampleOutput = document.createElement('pre');
                sampleOutput.textContent = question.sampleOutput;
                questionElement.appendChild(sampleOutput);
            }
        }
        
        // Display public test cases if any
        if (question.testCases && question.testCases.filter(tc => tc.isPublic).length > 0) {
            const testCasesTitle = document.createElement('h3');
            testCasesTitle.classList.add('section-title');
            testCasesTitle.innerHTML = '<i class="fas fa-clipboard-check"></i> Public Test Cases';
            questionElement.appendChild(testCasesTitle);
            
            const publicTestCases = question.testCases.filter(tc => tc.isPublic);
            
            publicTestCases.forEach((testCase, tcIndex) => {
                const testCaseTitle = document.createElement('h4');
                testCaseTitle.textContent = `Test Case ${tcIndex + 1}:`;
                testCaseTitle.style.fontWeight = '600';
                testCaseTitle.style.marginTop = '1rem';
                questionElement.appendChild(testCaseTitle);
                
                const testInputTitle = document.createElement('h5');
                testInputTitle.textContent = 'Input:';
                testInputTitle.style.fontWeight = '500';
                testInputTitle.style.marginTop = '0.5rem';
                questionElement.appendChild(testInputTitle);
                
                const testInput = document.createElement('pre');
                testInput.textContent = testCase.input;
                questionElement.appendChild(testInput);
                
                const testOutputTitle = document.createElement('h5');
                testOutputTitle.textContent = 'Expected Output:';
                testOutputTitle.style.fontWeight = '500';
                testOutputTitle.style.marginTop = '0.5rem';
                questionElement.appendChild(testOutputTitle);
                
                const testOutput = document.createElement('pre');
                testOutput.textContent = testCase.expectedOutput;
                questionElement.appendChild(testOutput);
            });
        }
        
        // Add code editor section
        const editorSection = document.createElement('div');
        editorSection.classList.add('editor-section');
        
        const editorTitle = document.createElement('h3');
        editorTitle.classList.add('section-title');
        editorTitle.innerHTML = '<i class="fas fa-code"></i> Your Solution';
        editorSection.appendChild(editorTitle);
        
        // Language selector
   const languageSelector = document.createElement('div');
    languageSelector.classList.add('language-selector');
    
    const languageLabel = document.createElement('label');
    languageLabel.htmlFor = `language-select-${question._id}`;
    languageLabel.textContent = 'Select Language:';
    languageSelector.appendChild(languageLabel);
    
    const languageSelect = document.createElement('select');
    languageSelect.id = `language-select-${question._id}`;
    languageSelect.classList.add('language-select');
    
    const languages = [
        { id: '71', name: 'Python (3.10.0)' },
        { id: '62', name: 'Java (OpenJDK 17)' },
        { id: '54', name: 'C++ (GCC 11.2.0)' },
        { id: '63', name: 'JavaScript (Node.js 16.13.0)' },
        { id: '51', name: 'C# (Mono 6.12.0)' },
        { id: '50', name: 'C (GCC 11.2.0)' }
    ];
    
    // Get the previously selected language for this question
    const selectedLanguageId = getSelectedLanguageForQuestion(question._id);
    
    languages.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.id;
        option.textContent = lang.name;
        if (lang.id === selectedLanguageId) {
            option.selected = true;
        }
        languageSelect.appendChild(option);
    });
    
    // Set the previous language tracker
    languageSelect.dataset.previousLanguage = selectedLanguageId;
    
    languageSelector.appendChild(languageSelect);
    editorSection.appendChild(languageSelector);
    
    // Code editor with proper initialization
    const codeEditorContainer = document.createElement('div');
    codeEditorContainer.classList.add('code-editor');
    
    const codeTextarea = document.createElement('textarea');
    codeTextarea.id = `codeEditor-${question._id}`;
    codeTextarea.classList.add('code-textarea');
    codeTextarea.spellcheck = false;
    
    // Load saved code for the selected language or use starter code
    const savedCode = getCodeForLanguage(question._id, selectedLanguageId);
    if (savedCode && savedCode.trim() !== '') {
        codeTextarea.value = savedCode;
    } else {
        codeTextarea.value = getStarterCode(question, selectedLanguageId);
    }
    
    codeEditorContainer.appendChild(codeTextarea);
    editorSection.appendChild(codeEditorContainer);
        // Editor buttons
           const editorButtons = document.createElement('div');
    editorButtons.classList.add('editor-buttons');
    
    const runCodeBtn = document.createElement('button');
    runCodeBtn.classList.add('btn', 'btn-primary');
    runCodeBtn.dataset.questionId = question._id;
    runCodeBtn.innerHTML = '<i class="fas fa-play"></i> Run Code';
    editorButtons.appendChild(runCodeBtn);
    
    const runCustomBtn = document.createElement('button');
    runCustomBtn.classList.add('btn', 'btn-secondary', 'run-custom-btn'); // Added a class for easier selection
    runCustomBtn.dataset.questionId = question._id;
    runCustomBtn.innerHTML = '<i class="fas fa-keyboard"></i> Custom Input';
    editorButtons.appendChild(runCustomBtn);
    
    const runAllTestsBtn = document.createElement('button');
    runAllTestsBtn.classList.add('btn', 'btn-secondary', 'run-all-tests-btn'); // Added a class for easier selection
    runAllTestsBtn.dataset.questionId = question._id;
    runAllTestsBtn.innerHTML = '<i class="fas fa-vials"></i> Run All Tests';
    editorButtons.appendChild(runAllTestsBtn);
        
        editorSection.appendChild(editorButtons);
        questionElement.appendChild(editorSection);
        
        // Custom test input section (hidden by default)
        const customTestSection = document.createElement('div');
        customTestSection.classList.add('custom-test-section');
        customTestSection.id = `custom-test-${question._id}`;
        customTestSection.style.display = 'none';
        
        const customTestTitle = document.createElement('h3');
        customTestTitle.classList.add('section-title');
        customTestTitle.innerHTML = '<i class="fas fa-keyboard"></i> Custom Test Input';
        customTestSection.appendChild(customTestTitle);
        
        const customInputLabel = document.createElement('p');
        customInputLabel.textContent = 'Enter your test input:';
        customTestSection.appendChild(customInputLabel);
        
        const customInputTextarea = document.createElement('textarea');
        customInputTextarea.id = `custom-input-${question._id}`;
        customInputTextarea.classList.add('custom-input-textarea');
        customInputTextarea.placeholder = 'Enter your test input here...';
        customTestSection.appendChild(customInputTextarea);
        
        const runCustomInputBtn = document.createElement('button');
        runCustomInputBtn.id = `run-custom-input-${question._id}`;
        runCustomInputBtn.classList.add('btn', 'btn-primary');
        runCustomInputBtn.innerHTML = '<i class="fas fa-play"></i> Run With Custom Input';
        customTestSection.appendChild(runCustomInputBtn);
        
        questionElement.appendChild(customTestSection);
        
        // Results section (hidden by default)
        const resultsSection = document.createElement('div');
        resultsSection.classList.add('results-section');
        resultsSection.id = `results-${question._id}`;
        resultsSection.style.display = 'none';
        
        const resultsTitle = document.createElement('h3');
        resultsTitle.classList.add('section-title');
        resultsTitle.innerHTML = '<i class="fas fa-clipboard-list"></i> Results';
        resultsSection.appendChild(resultsTitle);
        
        const resultOutput = document.createElement('div');
        resultOutput.id = `result-output-${question._id}`;
        resultOutput.classList.add('result-output');
        resultsSection.appendChild(resultOutput);
        
        const testResultsSection = document.createElement('div');
        testResultsSection.id = `test-results-${question._id}`;
        testResultsSection.classList.add('test-results');
        testResultsSection.style.display = 'none';
        
        const testResultsTitle = document.createElement('h4');
        testResultsTitle.classList.add('section-title');
        testResultsTitle.innerHTML = '<i class="fas fa-tasks"></i> Test Case Results';
        testResultsSection.appendChild(testResultsTitle);
        
        const testResultsTable = document.createElement('table');
        testResultsTable.classList.add('test-results-table');
        
        const tableHead = document.createElement('thead');
        tableHead.innerHTML = `
            <tr>
                <th>Test Case</th>
                <th>Status</th>
                <th>Time</th>
                <th>Memory</th>
                <th>Details</th>
            </tr>
        `;
        testResultsTable.appendChild(tableHead);
        
        const tableBody = document.createElement('tbody');
        tableBody.id = `test-results-body-${question._id}`;
        testResultsTable.appendChild(tableBody);
        
        testResultsSection.appendChild(testResultsTable);
        resultsSection.appendChild(testResultsSection);
        
        questionElement.appendChild(resultsSection);
        
        // Append the complete question element to the container
        questionContainer.appendChild(questionElement);
        
        // Add event listeners for code editor features
        setupCodeEditor(question._id);
        
        // Add event listeners for code execution buttons
        setupCodeExecutionButtons(question._id);
        
        // Add event listener for language selection to update the starter code
        const langSelect = document.getElementById(`language-select-${question._id}`);
    // languageSelect.addEventListener('change', () => {
    //     const selectedLanguage = languageSelect.value;
    //     const codeEditor = document.getElementById(`codeEditor-${question._id}`);
    //     const currentCode = codeEditor.value;
        
    //     // Save current code for the previously selected language
    //     const previousLanguage = languageSelect.dataset.previousLanguage || '71';
    //     saveCodeForLanguage(question._id, previousLanguage, currentCode);
        
    //     // Load code for the newly selected language
    //     const savedCodeForNewLang = getCodeForLanguage(question._id, selectedLanguage);
        
    //     if (savedCodeForNewLang && savedCodeForNewLang.trim() !== '') {
    //         // Use saved code if it exists and is not empty
    //         codeEditor.value = savedCodeForNewLang;
    //     } else {
    //         // Use starter code for the new language
    //         codeEditor.value = getStarterCode(question, selectedLanguage);
    //     }
        
    //     // Update the previous language tracker
    //     languageSelect.dataset.previousLanguage = selectedLanguage;
        
    //     // Save the new code and language selection
    //     saveCodeForLanguage(question._id, selectedLanguage, codeEditor.value);
    // });
    // Replace the existing language change event listener with this:
languageSelect.addEventListener('change', () => {
    const selectedLanguage = languageSelect.value;
    const codeEditor = document.getElementById(`codeEditor-${question._id}`);
    
    let currentCode = '';
    
    // Get current code from CodeMirror if it exists, otherwise from textarea
    if (codeEditor.codeMirrorInstance) {
        currentCode = codeEditor.codeMirrorInstance.getValue();
    } else {
        currentCode = codeEditor.value;
    }
    
    // Save current code for the previously selected language
    const previousLanguage = languageSelect.dataset.previousLanguage || '71';
    saveCodeForLanguage(question._id, previousLanguage, currentCode);
    
    // Load code for the newly selected language
    const savedCodeForNewLang = getCodeForLanguage(question._id, selectedLanguage);
    
    let newCode = '';
    if (savedCodeForNewLang && savedCodeForNewLang.trim() !== '') {
        newCode = savedCodeForNewLang;
    } else {
        newCode = getStarterCode(question, selectedLanguage);
    }
    
    // Update both CodeMirror and textarea
    if (codeEditor.codeMirrorInstance) {
        codeEditor.codeMirrorInstance.setValue(newCode);
        codeEditor.codeMirrorInstance.setOption('mode', getCodeMirrorMode(selectedLanguage));
    } else {
        codeEditor.value = newCode;
    }
    
    // Update the previous language tracker
    languageSelect.dataset.previousLanguage = selectedLanguage;
    
    // Save the new code and language selection
    saveCodeForLanguage(question._id, selectedLanguage, newCode);
});
    }


// function saveCodeForLanguage(questionId, languageId, code) {
//     const answers = JSON.parse(localStorage.getItem('examAnswers')) || { mcq: {}, coding: {} };
    
//     if (!answers.codingByLanguage) {
//         answers.codingByLanguage = {};
//     }
    
//     if (!answers.codingByLanguage[questionId]) {
//         answers.codingByLanguage[questionId] = {};
//     }
    
//     // Save code for specific language
//     answers.codingByLanguage[questionId][languageId] = code;
    
//     // Also save the currently selected language
//     answers.codingByLanguage[questionId].selectedLanguage = languageId;
    
//     localStorage.setItem('examAnswers', JSON.stringify(answers));
// }

function saveCodeForLanguage(questionId, languageId, code) {
    if (!questionId || !languageId || code === undefined) {
        console.warn('Invalid parameters for saveCodeForLanguage:', { questionId, languageId, code: !!code });
        return;
    }
    
    const answers = JSON.parse(localStorage.getItem('examAnswers')) || { mcq: {}, coding: {} };
    
    if (!answers.codingByLanguage) {
        answers.codingByLanguage = {};
    }
    
    if (!answers.codingByLanguage[questionId]) {
        answers.codingByLanguage[questionId] = {};
    }
    
    // Save code for specific language
    answers.codingByLanguage[questionId][languageId] = code;
    
    // Also save the currently selected language
    answers.codingByLanguage[questionId].selectedLanguage = languageId;
    
    // ALSO save to the old structure for backward compatibility
    if (!answers.coding) {
        answers.coding = {};
    }
    answers.coding[questionId] = code;
    
    localStorage.setItem('examAnswers', JSON.stringify(answers));
    
    console.log(`Saved code for question ${questionId}, language ${languageId}:`, {
        codeLength: code.length,
        firstLine: code.split('\n')[0].substring(0, 50) + '...'
    });
}


function getCodeForLanguage(questionId, languageId) {
    const answers = JSON.parse(localStorage.getItem('examAnswers'));
    
    if (answers && 
        answers.codingByLanguage && 
        answers.codingByLanguage[questionId] && 
        answers.codingByLanguage[questionId][languageId]) {
        return answers.codingByLanguage[questionId][languageId];
    }
    
    return null;
}
    // Function to set up code editor
    // Function to set up code editor with CodeMirror
// function setupCodeEditor(questionId) {
//     const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
//     if (!codeTextarea) return;
    
//     // Get the language selector
//     const languageSelect = document.getElementById(`language-select-${questionId}`);
//     const selectedLanguageId = languageSelect ? languageSelect.value : '71';
    
//     // Hide the original textarea
//     codeTextarea.style.display = 'none';
    
//     // Create CodeMirror instance
//     const editor = CodeMirror(codeTextarea.parentNode, {
//         value: codeTextarea.value,
//         mode: getCodeMirrorMode(selectedLanguageId),
//         theme: document.body.classList.contains('dark-theme') ? 'monokai' : 'github',
//         lineNumbers: true,
//         autoCloseBrackets: true,
//         matchBrackets: true,
//         styleActiveLine: true,
//         indentUnit: 4,
//         tabSize: 4,
//         indentWithTabs: false,
//         lineWrapping: false,
//         extraKeys: {
//             "Tab": function(cm) {
//                 if (cm.somethingSelected()) {
//                     cm.indentSelection("add");
//                 } else {
//                     cm.replaceSelection("    ");
//                 }
//             },
//             "Shift-Tab": function(cm) {
//                 cm.indentSelection("subtract");
//             }
//         }
//     });
    
//     // Store reference to editor
//     codeTextarea.codeMirrorInstance = editor;
    
//     // Update textarea value when editor changes
//     editor.on('change', function() {
//         codeTextarea.value = editor.getValue();
        
//         // Debounce to avoid saving too frequently
//         clearTimeout(codeTextarea.saveTimeout);
//         codeTextarea.saveTimeout = setTimeout(() => {
//             const currentLanguage = languageSelect ? languageSelect.value : '71';
//             saveCodeForLanguage(questionId, currentLanguage, editor.getValue());
//             updateProgress();
//         }, 1000);
//     });
    
//     // Handle language changes
//     if (languageSelect) {
//         const originalChangeHandler = languageSelect.onchange;
//         languageSelect.onchange = function() {
//             // Call original handler first
//             if (originalChangeHandler) {
//                 originalChangeHandler.call(this);
//             }
            
//             // Update CodeMirror mode
//             const newMode = getCodeMirrorMode(this.value);
//             editor.setOption('mode', newMode);
//         };
//     }
    
//     // Handle theme changes
//     const themeObserver = new MutationObserver(function(mutations) {
//         mutations.forEach(function(mutation) {
//             if (mutation.attributeName === 'class') {
//                 const isDark = document.body.classList.contains('dark-theme');
//                 editor.setOption('theme', isDark ? 'monokai' : 'github');
//             }
//         });
//     });
    
//     themeObserver.observe(document.body, {
//         attributes: true,
//         attributeFilter: ['class']
//     });
    
//     // Set up copy-paste control
//     if (window.copyPasteControl) {
//         window.copyPasteControl.setupCodeEditor(questionId);
//         console.log(`Copy-paste control set up for editor: ${questionId}`);
//     }
    
//     // Refresh editor after a short delay to ensure proper rendering
//     setTimeout(() => {
//         editor.refresh();
//     }, 100);
// }
function setupCodeEditor(questionId) {
    const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
    if (!codeTextarea) return;
    
    // Get the language selector
    const languageSelect = document.getElementById(`language-select-${questionId}`);
    const selectedLanguageId = languageSelect ? languageSelect.value : '71';
    
    // Hide the original textarea
    codeTextarea.style.display = 'none';
    
    // Create a toolbar for the editor (optional)
    const toolbar = document.createElement('div');
    toolbar.className = 'code-editor-toolbar';
    toolbar.innerHTML = `
        <div class="code-editor-info">
            <span>Language: <strong>${LANGUAGE_CONFIG[selectedLanguageId]?.name || 'Python'}</strong></span>
            <span>Lines: <span id="line-count-${questionId}">1</span></span>
        </div>
        <div class="code-editor-actions">
            <button type="button" onclick="formatCode('${questionId}')" title="Format Code">
                <i class="fas fa-indent"></i>
            </button>
            <button type="button" onclick="toggleWordWrap('${questionId}')" title="Toggle Word Wrap">
                <i class="fas fa-align-left"></i>
            </button>
        </div>
    `;
    
    // Insert toolbar before the code editor
    codeTextarea.parentNode.insertBefore(toolbar, codeTextarea);
    
    // Create CodeMirror instance with enhanced options
    const editor = CodeMirror(codeTextarea.parentNode, {
        value: codeTextarea.value,
        mode: getCodeMirrorMode(selectedLanguageId),
        theme: document.body.classList.contains('dark-theme') ? 'monokai' : 'github',
        lineNumbers: true,
        autoCloseBrackets: true,
        matchBrackets: true,
        styleActiveLine: true,
        indentUnit: 4,
        tabSize: 5,
        indentWithTabs: false,
        lineWrapping: false,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        highlightSelectionMatches: {showToken: /\w/, annotateScrollbar: true},
        searchCursor: true,
        autoRefresh: true,
        viewportMargin: 10,
        extraKeys: {
            "Tab": function(cm) {
                if (cm.somethingSelected()) {
                    cm.indentSelection("add");
                } else {
                    cm.replaceSelection("    ");
                }
            },
            "Shift-Tab": function(cm) {
                cm.indentSelection("subtract");
            },
            "Ctrl-/": function(cm) {
                cm.toggleComment();
            },
            "Cmd-/": function(cm) {
                cm.toggleComment();
            },
            "F11": function(cm) {
                cm.setOption("fullScreen", !cm.getOption("fullScreen"));
            },
            "Esc": function(cm) {
                if (cm.getOption("fullScreen")) cm.setOption("fullScreen", true);
            }
        }
    });
    
    // Store reference to editor
    codeTextarea.codeMirrorInstance = editor;
    
    // Update line count display
    const updateLineCount = () => {
        const lineCountSpan = document.getElementById(`line-count-${questionId}`);
        if (lineCountSpan) {
            lineCountSpan.textContent = editor.lineCount();
        }
    };
    
    // Update textarea value and line count when editor changes
    editor.on('change', function() {
        codeTextarea.value = editor.getValue();
        updateLineCount();
        
        // Debounce to avoid saving too frequently
        clearTimeout(codeTextarea.saveTimeout);
        codeTextarea.saveTimeout = setTimeout(() => {
            const currentLanguage = languageSelect ? languageSelect.value : '71';
            saveCodeForLanguage(questionId, currentLanguage, editor.getValue());
            updateProgress();
        }, 1000);
    });
    
    // Update line count initially
    updateLineCount();
    
    // Handle language changes
    if (languageSelect) {
        const originalChangeHandler = languageSelect.onchange;
        languageSelect.onchange = function() {
            // Update toolbar info
            const toolbarInfo = toolbar.querySelector('.code-editor-info span');
            if (toolbarInfo) {
                toolbarInfo.innerHTML = `Language: <strong>${LANGUAGE_CONFIG[this.value]?.name || 'Unknown'}</strong>`;
            }
            
            // Call original handler
            if (originalChangeHandler) {
                originalChangeHandler.call(this);
            }
            
            // Update CodeMirror mode
            const newMode = getCodeMirrorMode(this.value);
            editor.setOption('mode', newMode);
        };
    }
    
    // Handle theme changes
    const themeObserver = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'class') {
                const isDark = document.body.classList.contains('dark-theme');
                editor.setOption('theme', isDark ? 'monokai' : 'github');
            }
        });
    });
    
    themeObserver.observe(document.body, {
        attributes: true,
        attributeFilter: ['class']
    });
    
    // Set up copy-paste control
    if (window.copyPasteControl) {
        window.copyPasteControl.setupCodeEditor(questionId);
        console.log(`Copy-paste control set up for editor: ${questionId}`);
    }
    
    // Make editor resizable
    editor.on('refresh', function() {
        const editorElement = editor.getWrapperElement();
        if (editorElement) {
            editorElement.style.resize = 'vertical';
            editorElement.style.overflow = 'auto';
        }
    });
    
    // Refresh editor after a short delay to ensure proper rendering
    setTimeout(() => {
        editor.refresh();
        editor.focus();
    }, 100);
    
    // Add window resize listener to refresh editor
    window.addEventListener('resize', () => {
        setTimeout(() => editor.refresh(), 100);
    });
}

// Utility functions for editor enhancements
function formatCode(questionId) {
    const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
    if (codeTextarea && codeTextarea.codeMirrorInstance) {
        const editor = codeTextarea.codeMirrorInstance;
        const totalLines = editor.lineCount();
        editor.autoFormatRange({line: 0, ch: 0}, {line: totalLines});
    }
}

function toggleWordWrap(questionId) {
    const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
    if (codeTextarea && codeTextarea.codeMirrorInstance) {
        const editor = codeTextarea.codeMirrorInstance;
        const currentWrap = editor.getOption('lineWrapping');
        editor.setOption('lineWrapping', !currentWrap);
    }
}
// Helper function to get CodeMirror mode based on language ID
function getCodeMirrorMode(languageId) {
    const modeMap = {
        '71': 'python',           // Python
        '62': 'text/x-java',      // Java
        '54': 'text/x-c++src',    // C++
        '63': 'javascript',       // JavaScript
        '51': 'text/x-csharp',    // C#
        '50': 'text/x-csrc'       // C
    };
    
    return modeMap[languageId] || 'python';
}
//     function setupCodeEditor(questionId) {
//         const codeEditor = document.getElementById(`codeEditor-${questionId}`);
        
//         // Add event listener to save code when typing
//         codeEditor.addEventListener('input', () => {
//             // Debounce to avoid saving too frequently
//             clearTimeout(codeEditor.saveTimeout);
//             codeEditor.saveTimeout = setTimeout(() => {
//                 saveCodingAnswer(questionId, codeEditor.value);
//                 updateProgress();
//             }, 1000);
//         });
        
//         // Add tab key support
//         codeEditor.addEventListener('keydown', function(e) {
//             if (e.key === 'Tab') {
//                 e.preventDefault();
//                 const start = this.selectionStart;
//                 const end = this.selectionEnd;
                
//                 // Insert tab at the cursor position
//                 this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                
//                 // Move the cursor position after the tab
//                 this.selectionStart = this.selectionEnd = start + 4;
//             }
//         });
//     }
//  if (window.copyPasteControl) {
//         window.copyPasteControl.setupCodeEditor(questionId);
//         console.log(`Copy-paste control set up for editor: ${questionId}`);
//     }
    // Function to set up code execution buttons
    function setupCodeExecutionButtons(questionId) {
        // Run code button
        const runCodeBtn = document.querySelector(`.btn-primary[data-question-id="${questionId}"]`);
        if (runCodeBtn) {
            runCodeBtn.addEventListener('click', () => runCode(questionId));
        }
        
        // Run custom test button
   const runCustomBtn = document.querySelector(`.run-custom-btn[data-question-id="${questionId}"]`);
    if (runCustomBtn) {
        runCustomBtn.addEventListener('click', () => {
            const customTestSection = document.getElementById(`custom-test-${questionId}`);
            // Toggle the display
            if (customTestSection.style.display === 'none') {
                customTestSection.style.display = 'block';
            } else {
                customTestSection.style.display = 'none';
            }
        });
    }
        
        // Run with custom input button
           const runCustomInputBtn = document.getElementById(`run-custom-input-${questionId}`);
    if (runCustomInputBtn) {
        runCustomInputBtn.addEventListener('click', () => runCodeWithCustomInput(questionId));
    }
    
    // Run all tests button - FIXED
    const runAllTestsBtn = document.querySelector(`.run-all-tests-btn[data-question-id="${questionId}"]`);
    if (runAllTestsBtn) {
        runAllTestsBtn.addEventListener('click', () => runAllTests(questionId));
    }
    }

    // Helper function to get starter code for a language
    function getStarterCode(question, languageId) {
        if (!question.starterCode || question.starterCode.length === 0) {
            return question.solutionTemplate || '';
        }
        
        // Find the starter code for the selected language
        const starter = question.starterCode.find(code => code.language === getLanguageName(languageId));
        
        // If found, return that code, otherwise return the first available or template
        return starter ? starter.code : (question.starterCode[0].code || question.solutionTemplate || '');
    }

    // Helper function to check if current code is a starter code
    function isStarterCode(code, question, languageId) {
        if (!question || !question.starterCode) return false;
        
        // First check - is the code the starter code for the CURRENT language?
        if (languageId) {
            const currentLanguageName = getLanguageName(languageId);
            const starterForCurrentLanguage = question.starterCode.find(
                starter => starter.language === currentLanguageName
            );
            
            if (starterForCurrentLanguage && starterForCurrentLanguage.code === code) {
                return true;
            }
        }
        
        // Second check - is the code ANY starter code from ANY language?
        return question.starterCode.some(starter => starter.code === code);
    }

    // Helper function to convert languageId to language name
    function getLanguageName(languageId) {
        const languageMap = {
            '62': 'java',
            '71': 'python',
            '54': 'cpp',
            '63': 'javascript',
            '51': 'csharp',
            '50': 'c'
        };
        
        return languageMap[languageId] || 'python';
    }

    // Function to save MCQ answer to localStorage
    function saveMCQAnswer(questionId, optionIndex, optionText) {
        const answers = JSON.parse(localStorage.getItem('examAnswers')) || { mcq: {}, coding: {} };
        if (!answers.mcq) {
            answers.mcq = {};
        }
        answers.mcq[questionId] = {
            index: optionIndex,
            value: optionText
        };
        localStorage.setItem('examAnswers', JSON.stringify(answers));
        
        // Mark the question as answered in navigation
        updateQuestionNavigation();
    }

    // Function to get selected MCQ answer
    function getSelectedMCQAnswer(questionId, optionIndex) {
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        return answers && 
               answers.mcq && 
               answers.mcq[questionId] && 
               answers.mcq[questionId].index === optionIndex;
    }

    // Function to save coding answer to localStorage
    function saveCodingAnswer(questionId, code) {
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        if (!answers.coding) {
            answers.coding = {};
        }
        answers.coding[questionId] = code;
        localStorage.setItem('examAnswers', JSON.stringify(answers));
        
        // Mark the question as answered in navigation
        updateQuestionNavigation();
    }

    // Function to get saved coding answer
    function getSavedCodingAnswer(questionId) {
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        return answers && answers.coding && answers.coding[questionId] ? answers.coding[questionId] : '';
    }

    // Function to check for unanswered questions
    function checkUnansweredQuestions() {
        const examData = JSON.parse(localStorage.getItem('currentExam'));
        const answers = JSON.parse(localStorage.getItem('examAnswers'));
        
        // Initialize arrays to store question IDs
        let mcqQuestionIds = [];
        let codingQuestionIds = [];
        
        // Get all question IDs based on the exam type
        if (examData.questionType === "mcq" || examData.questionType === "mcq&coding") {
            const mcqQuestions = JSON.parse(localStorage.getItem('mcqQuestions'));
            mcqQuestionIds = mcqQuestions.map(q => q._id);
        }
        
        if (examData.questionType === "coding" || examData.questionType === "mcq&coding") {
            const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
            codingQuestionIds = codingQuestions.map(q => q._id);
        }
        
        // Check which questions have been answered
        const answeredMcqIds = answers.mcq ? Object.keys(answers.mcq) : [];
        const answeredCodingIds = answers.coding ? Object.keys(answers.coding) : [];
        
        // Find unanswered questions
        const unansweredMcqIds = mcqQuestionIds.filter(id => !answeredMcqIds.includes(id));
        const unansweredCodingIds = codingQuestionIds.filter(id => !answeredCodingIds.includes(id));
        
        // Mark unanswered questions in the navigation
        const navButtons = document.querySelectorAll('.nav-button');
        navButtons.forEach(button => {
            const index = parseInt(button.dataset.index);
            let isUnanswered = false;
            
            // Check if this is an unanswered MCQ question
            if (index < mcqQuestionIds.length && unansweredMcqIds.includes(mcqQuestionIds[index])) {
                isUnanswered = true;
            }
            
            // Check if this is an unanswered coding question
            if (examData.questionType === "mcq&coding" && index >= mcqQuestionIds.length) {
                const codingIndex = index - mcqQuestionIds.length;
                if (codingIndex < codingQuestionIds.length && 
                    unansweredCodingIds.includes(codingQuestionIds[codingIndex])) {
                    isUnanswered = true;
                }
            } else if (examData.questionType === "coding") {
                if (unansweredCodingIds.includes(codingQuestionIds[index])) {
                    isUnanswered = true;
                }
            }
            
            // Mark unanswered questions with a red border
            if (isUnanswered) {
                button.classList.add('unanswered');
            } else {
                button.classList.remove('unanswered');
            }
        });
        
        return {
            unansweredMcq: unansweredMcqIds.length,
            unansweredCoding: unansweredCodingIds.length,
            total: unansweredMcqIds.length + unansweredCodingIds.length
        };
    }

    
function getSelectedLanguageForQuestion(questionId) {
    const answers = JSON.parse(localStorage.getItem('examAnswers'));
    
    if (answers && 
        answers.codingByLanguage && 
        answers.codingByLanguage[questionId] && 
        answers.codingByLanguage[questionId].selectedLanguage) {
        return answers.codingByLanguage[questionId].selectedLanguage;
    }
    
    return '71'; // Default to Python
}
    function setupQuestionNavigation() {
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    const navigationContainer = document.getElementById('questionNavigation');
    
    // Clear previous navigation
    navigationContainer.innerHTML = '';
    
    // Determine total questions
    let totalQuestions = getTotalQuestions(examData);
    
    // Create navigation buttons
    for (let i = 0; i < totalQuestions; i++) {
        const navButton = document.createElement('button');
        navButton.textContent = i + 1;
        navButton.classList.add('nav-button');
        navButton.dataset.index = i;
        navButton.addEventListener('click', () => {
            console.log(`Navigation button clicked: ${i}`); // Debug log
            loadQuestion(i);
        });
        navigationContainer.appendChild(navButton);
    }
    
    // Set up next/prev buttons with better error handling
    const prevButton = document.getElementById('prevQuestion');
    const nextButton = document.getElementById('nextQuestion');
    
    // Remove any existing event listeners
    if (prevButton) {
        const newPrevButton = prevButton.cloneNode(true);
        prevButton.parentNode.replaceChild(newPrevButton, prevButton);
        
        newPrevButton.addEventListener('click', () => {
            const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
            console.log(`Previous button clicked. Current index: ${currentIndex}`); // Debug log
            if (currentIndex > 0) {
                loadQuestion(currentIndex - 1);
            }
        });
    }
    
    if (nextButton) {
        const newNextButton = nextButton.cloneNode(true);
        nextButton.parentNode.replaceChild(newNextButton, nextButton);
        
        newNextButton.addEventListener('click', () => {
            const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
            console.log(`Next button clicked. Current index: ${currentIndex}, Total: ${totalQuestions}`); // Debug log
            if (currentIndex < totalQuestions - 1) {
                loadQuestion(currentIndex + 1);
            }
        });
    }
    
    // Set up the submit button
    const submitButton = document.getElementById('submitExam');
    if (submitButton) {
        // Remove existing listener and add new one
        const newSubmitButton = submitButton.cloneNode(true);
        submitButton.parentNode.replaceChild(newSubmitButton, submitButton);
        newSubmitButton.addEventListener('click', confirmSubmitExam);
    }
    
    // Check for unanswered questions
    checkUnansweredQuestions();
}
   
function updateQuestionNavigation(currentIndex) {
    // If currentIndex is not provided, get it from localStorage
    if (currentIndex === undefined) {
        currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
    }
    
    console.log(`Updating navigation for index: ${currentIndex}`); // Debug log
    
    const navButtons = document.querySelectorAll('.nav-button');
    navButtons.forEach((button, buttonIndex) => {
        button.classList.remove('active');
        if (buttonIndex === currentIndex) {
            button.classList.add('active');
        }
    });
    
    // Update next/prev button states
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    let totalQuestions = getTotalQuestions(examData);
    
    const prevButton = document.getElementById('prevQuestion');
    const nextButton = document.getElementById('nextQuestion');
    
    if (prevButton) {
        prevButton.disabled = currentIndex === 0;
    }
    
    if (nextButton) {
        nextButton.disabled = currentIndex === totalQuestions - 1;
    }
    
    // Check for unanswered questions
    checkUnansweredQuestions();
}

    // Function to start exam timer
    function startExamTimer() {
        const endTimeStr = localStorage.getItem('examEndTime');
        if (!endTimeStr) return;
        
        const endTime = parseInt(endTimeStr);
        const timerDisplay = document.getElementById('examTimer');
        
        const timer = setInterval(() => {
            const now = new Date().getTime();
            const timeLeft = endTime - now;
            
            if (timeLeft <= 0) {
                clearInterval(timer);
                timerDisplay.innerHTML = '<i class="fas fa-clock"></i> Time\'s up!';
                timerDisplay.classList.add('timer-critical');
                submitExam(); // Auto-submit when time's up
                return;
            }
            
            // Calculate time left
            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
            
            // Format time and update display
            timerDisplay.innerHTML = `<i class="fas fa-clock"></i> ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Add warning class when less than 5 minutes left
            if (timeLeft < 5 * 60 * 1000) {
                timerDisplay.classList.add('timer-critical');
            }
        }, 1000);
    }

    // Function to submit exam
    // function submitExam() {
    //     const examData = JSON.parse(localStorage.getItem('currentExam'));
    //     const answers = JSON.parse(localStorage.getItem('examAnswers'));
        
    //     // Show loading indicator
    //     const submitButton = document.getElementById('submitExam');
    //     const originalButtonText = submitButton.innerHTML;
    //     submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
    //     submitButton.disabled = true;
        
    //     // Prepare submission data according to Mongoose schema format
    //     const submissionData = {
    //         exam: examData._id,
    //         mcqAnswers: [],
    //         codingAnswers: []
    //     };
        
    //     // Process MCQ answers
    //     if (answers.mcq && Object.keys(answers.mcq).length > 0) {
    //         for (const questionId in answers.mcq) {
    //             const answerData = answers.mcq[questionId];
                
    //             // Send the actual option text (value) instead of just the index
    //             submissionData.mcqAnswers.push({
    //                 questionId: questionId,
    //                 selectedOption: answerData.value || answerData.index.toString()
    //             });
    //         }
    //     }
        
    //     // Process coding answers
    //       if (answers.codingByLanguage && Object.keys(answers.codingByLanguage).length > 0) {
    //     for (const questionId in answers.codingByLanguage) {
    //         const questionData = answers.codingByLanguage[questionId];
    //         const selectedLanguage = questionData.selectedLanguage || '71';
    //         const codeForSelectedLanguage = questionData[selectedLanguage];
            
    //         if (codeForSelectedLanguage && codeForSelectedLanguage.trim() !== '') {
    //             submissionData.codingAnswers.push({
    //                 questionId: questionId,
    //                 code: codeForSelectedLanguage,
    //                 language: parseInt(selectedLanguage)
    //             });
    //         }
    //     }
    // }
    //        const userId = document.getElementById('user').textContent;
    // const examId = document.getElementById('exam').textContent;
    //         const integrity = examIntegrity.init({
    //     // Required exam information
    //     examId: examId,
    //     userId: userId,
        
    //     // Optional: Custom API endpoints
    //     apiEndpoints: {
    //         integrityUpdate: '/update-integrity',
    //         activityPing: '/dashboard/see-active',
    //         saveImage: '/save-image'
    //     },
        
    //     // Optional: Custom behavior configuration
    //     config: {
    //         maxViolations: 5,                // Default: 3
    //         maxRefreshes: 3,                 // Default: 2
    //         pingInterval: 30000,             // Default: 20000 (20 seconds)
    //         webcamCaptureInterval: 10000     // Default: 5000 (5 seconds)
    //     },
        
    //     // Optional: Callback when violations trigger auto-submit
    //     onAutoSubmit: function(reason) {
    //         console.log(`Auto-submitting exam due to: ${reason}`);
            
    //         // Your custom submit logic
    //         document.getElementById('examForm').submit();
            
    //         // Optional: Redirect after submission
    //         setTimeout(() => {
    //             window.location.href = '/exam-complete';
    //         }, 1000);
    //     },
        
    //     // Optional: Start webcam automatically on init
    //     startWebcam: false
    // });
    
    //             const violations = integrity.getViolationCounts();
    //     console.log('Final violation counts:', violations);
        
    //     // Stop integrity monitoring
    //     integrity.stop();
        
    //     console.log('Submission data:', submissionData);
        
    //     // Send submission to server using fetch API with JSON
    //     fetch('/dashboard/submit-test', {
    //         method: 'POST',
    //         headers: {
    //             'Content-Type': 'application/json'
    //         },
    //         body: JSON.stringify(submissionData)
    //     })
    //     .then(response => {
    //         if (!response.ok) {
    //             if (response.redirected) {
    //                 window.location.href = response.url;
    //                 return;
    //             }
    //             return response.text().then(text => {
    //                 throw new Error(text || 'Submission failed');
    //             });
    //         }
    //         return response.json();
    //     })
    //     .then(data => {
    //         showSuccessMessage('Exam submitted successfully!');
            
    //         // Clear exam data from localStorage
    //         clearExamData();
            
    //         // Redirect to dashboard or results page after a short delay
    //         setTimeout(() => {
    //             window.close();
    //         }, 1500);
    //     })
    //     .catch(error => {
    //         console.error('Error submitting exam:', error);
    //         showErrorMessage(`There was an error submitting your exam: ${error.message}`);
            
    //         // Reset button state
    //         submitButton.innerHTML = originalButtonText;
    //         submitButton.disabled = false;
    //     });
    // }
// Function to submit exam - FIXED VERSION
function submitExam() {
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    const answers = JSON.parse(localStorage.getItem('examAnswers'));
    
    // Show loading indicator
    const submitButton = document.getElementById('submitExam');
    const originalButtonText = submitButton.innerHTML;
    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
    submitButton.disabled = true;
    
    // CRITICAL FIX: Save current code before submitting
    const currentIndex = parseInt(localStorage.getItem('currentQuestionIndex')) || 0;
    const currentLanguageSelect = document.querySelector(`select[id^="language-select-"]`);
    const currentCodeEditor = document.querySelector(`textarea[id^="codeEditor-"]`);
    
    if (currentLanguageSelect && currentCodeEditor) {
        const questionId = currentCodeEditor.id.replace('codeEditor-', '');
        const currentLanguage = currentLanguageSelect.value;
        const currentCode = currentCodeEditor.value;
        
        console.log('Saving current code before submit:', {
            questionId,
            currentLanguage,
            codeLength: currentCode.length
        });
        
        // Save the current code
        saveCodeForLanguage(questionId, currentLanguage, currentCode);
    }
    
    // Refresh answers after saving current code
    const updatedAnswers = JSON.parse(localStorage.getItem('examAnswers'));
        if (window.copyPasteControl) {
        window.copyPasteControl.stop();
        console.log('Copy-paste control stopped');
    }

    // Prepare submission data
    const submissionData = {
        exam: examData._id,
        mcqAnswers: [],
        codingAnswers: []
    };
    
    // Process MCQ answers
    if (updatedAnswers.mcq && Object.keys(updatedAnswers.mcq).length > 0) {
        for (const questionId in updatedAnswers.mcq) {
            const answerData = updatedAnswers.mcq[questionId];
            submissionData.mcqAnswers.push({
                questionId: questionId,
                selectedOption: answerData.value || answerData.index.toString()
            });
        }
    }
    
    // FIXED: Process coding answers with better logic
    const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions')) || [];
    
    console.log('Processing coding questions:', codingQuestions.length);
    console.log('Available coding answers:', updatedAnswers.codingByLanguage);
    
    for (const question of codingQuestions) {
        const questionId = question._id;
        let codeToSubmit = null;
        let languageToSubmit = '71'; // Default to Python
        
        console.log(`Processing question ${questionId}...`);
        
        // PRIMARY: Check the new language-specific structure
        if (updatedAnswers.codingByLanguage && 
            updatedAnswers.codingByLanguage[questionId]) {
            
            const questionData = updatedAnswers.codingByLanguage[questionId];
            const selectedLanguage = questionData.selectedLanguage || '71';
            const codeForSelectedLanguage = questionData[selectedLanguage];
            
            console.log(`Found language data for ${questionId}:`, {
                selectedLanguage,
                hasCode: !!codeForSelectedLanguage,
                codeLength: codeForSelectedLanguage ? codeForSelectedLanguage.length : 0
            });
            
            if (codeForSelectedLanguage && codeForSelectedLanguage.trim() !== '') {
                // IMPROVED: Better starter code detection
                const isStarter = isStarterCode(codeForSelectedLanguage, question, selectedLanguage);
                console.log(`Is starter code for ${questionId}:`, isStarter);
                
                if (!isStarter) {
                    codeToSubmit = codeForSelectedLanguage;
                    languageToSubmit = selectedLanguage;
                    console.log(`Selected code for ${questionId} (language ${selectedLanguage})`);
                } else {
                    console.log(`Skipping starter code for ${questionId}`);
                }
            }
        }
        
        // FALLBACK: Check the old coding structure if no valid code found
        if (!codeToSubmit && updatedAnswers.coding && updatedAnswers.coding[questionId]) {
            const fallbackCode = updatedAnswers.coding[questionId];
            console.log(`Checking fallback code for ${questionId}:`, {
                hasCode: !!fallbackCode,
                codeLength: fallbackCode ? fallbackCode.length : 0
            });
            
            if (fallbackCode && fallbackCode.trim() !== '' && 
                !isStarterCode(fallbackCode, question)) {
                codeToSubmit = fallbackCode;
                languageToSubmit = '71'; // Default language
                console.log(`Using fallback code for ${questionId}`);
            }
        }
        
        // ADDITIONAL FALLBACK: Check if there's code in any language for this question
        if (!codeToSubmit && updatedAnswers.codingByLanguage && 
            updatedAnswers.codingByLanguage[questionId]) {
            
            const questionData = updatedAnswers.codingByLanguage[questionId];
            
            // Try all available languages for this question
            const availableLanguages = ['71', '62', '54', '63', '51', '50'];
            for (const langId of availableLanguages) {
                if (questionData[langId] && questionData[langId].trim() !== '') {
                    const code = questionData[langId];
                    if (!isStarterCode(code, question, langId)) {
                        codeToSubmit = code;
                        languageToSubmit = langId;
                        console.log(`Found code in alternative language ${langId} for ${questionId}`);
                        break;
                    }
                }
            }
        }
        
        // Submit the code if we found valid code
        if (codeToSubmit) {
            submissionData.codingAnswers.push({
                questionId: questionId,
                code: codeToSubmit,
                language: parseInt(languageToSubmit)
            });
            console.log(`✓ Added coding answer for question ${questionId}:`, {
                codeLength: codeToSubmit.length,
                language: languageToSubmit,
                firstLine: codeToSubmit.split('\n')[0].substring(0, 50) + '...'
            });
        } else {
            console.log(`✗ No valid code found for question ${questionId}`);
        }
    }
    
    console.log('Final submission data:', {
        exam: submissionData.exam,
        mcqCount: submissionData.mcqAnswers.length,
        codingCount: submissionData.codingAnswers.length,
        codingAnswers: submissionData.codingAnswers.map(ca => ({
            questionId: ca.questionId,
            language: ca.language,
            codeLength: ca.code.length
        }))
    });
    
    // Get integrity data
    const userId = document.getElementById('user').textContent;
    const examId = document.getElementById('exam').textContent;
    
    const integrity = examIntegrity.init({
        examId: examId,
        userId: userId,
        apiEndpoints: {
            integrityUpdate: '/update-integrity',
            activityPing: '/dashboard/see-active',
            saveImage: '/save-image'
        },
        config: {
            maxViolations: 5,
            maxRefreshes: 3,
            pingInterval: 30000,
            webcamCaptureInterval: 10000
        },
        onAutoSubmit: function(reason) {
            console.log(`Auto-submitting exam due to: ${reason}`);
            document.getElementById('examForm').submit();
            setTimeout(() => {
                window.location.href = '/exam-complete';
            }, 1000);
        },
        startWebcam: false
    });
    
    const violations = integrity.getViolationCounts();
    console.log('Final violation counts:', violations);
    
    // Stop integrity monitoring
    integrity.stop();
    
    // Send submission to server
    fetch('/dashboard/submit-test', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(submissionData)
    })
    .then(response => {
        if (!response.ok) {
            if (response.redirected) {
                window.location.href = response.url;
                return;
            }
            return response.text().then(text => {
                throw new Error(text || 'Submission failed');
            });
        }
        return response.json();
    })
    .then(data => {
        showSuccessMessage('Exam submitted successfully!');
        
        // Clear exam data from localStorage
        clearExamData();
        
        // Redirect after delay
        setTimeout(() => {
            window.close();
        }, 1500);
    })
    .catch(error => {
        console.error('Error submitting exam:', error);
        showErrorMessage(`There was an error submitting your exam: ${error.message}`);
        
        // Reset button state
        submitButton.innerHTML = originalButtonText;
        submitButton.disabled = false;
    });
}

//     // Function to show success message
    function showSuccessMessage(message) {
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container success-message';
        messageContainer.innerHTML = `
            <div class="message-content">
                <i class="fas fa-check-circle"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(messageContainer);
        
        setTimeout(() => {
            messageContainer.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            messageContainer.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(messageContainer);
            }, 500);
        }, 3000);
    }

    // Function to show error message
    function showErrorMessage(message) {
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container error-message';
        messageContainer.innerHTML = `
            <div class="message-content">
                <i class="fas fa-exclamation-circle"></i>
                <span>${message}</span>
            </div>
        `;
        document.body.appendChild(messageContainer);
        
        setTimeout(() => {
            messageContainer.classList.add('show');
        }, 10);
        
        setTimeout(() => {
            messageContainer.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(messageContainer);
            }, 500);
        }, 5000);
    }

    // Helper function to clear exam data
function clearExamData() {
    localStorage.removeItem('currentExam');
    localStorage.removeItem('mcqQuestions');
    localStorage.removeItem('codingQuestions');
    localStorage.removeItem('currentQuestionIndex');
    localStorage.removeItem('examEndTime');
    localStorage.removeItem('examAnswers');
}

    // Function to confirm submission
    function confirmSubmitExam() {
        // Check if all questions have been attempted
        const unansweredStatus = checkUnansweredQuestions();
        
        // Create a custom confirmation modal
        const modalContainer = document.createElement('div');
        modalContainer.className = 'modal-container';
        
        let confirmMessage = '<h3>Submit Exam?</h3>';
        
        if (unansweredStatus.total > 0) {
            confirmMessage += `
                <p class="warning"><i class="fas fa-exclamation-triangle"></i> You have ${unansweredStatus.total} unanswered question(s).</p>
                <p>Are you sure you want to submit your exam?</p>
            `;
        } else {
            confirmMessage += `
                <p>You have answered all questions. Are you ready to submit your exam?</p>
            `;
        }
        
        modalContainer.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <span class="modal-close">&times;</span>
                </div>
                <div class="modal-body">
                    ${confirmMessage}
                </div>
                <div class="modal-footer">
                    <button id="modal-cancel" class="btn btn-secondary">Cancel</button>
                    <button id="modal-confirm" class="btn btn-danger">Yes, Submit</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modalContainer);
        
        // Add event listeners
        document.querySelector('.modal-close').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
        });
        
        document.querySelector('.modal-backdrop').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
        });
        
        document.getElementById('modal-cancel').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
        });
        
        document.getElementById('modal-confirm').addEventListener('click', () => {
            document.body.removeChild(modalContainer);
            submitExam();
        });
    }

    // Judge0 API Functions
// Judge0 API Configuration - Updated and Fixed
const JUDGE0_CONFIG = {
    // Change this URL to RapidAPI's Judge0 endpoint
    baseUrl: 'https://judge0-ce.p.rapidapi.com',
    endpoints: {
        submissions: '/submissions',
        status: '/submissions'
    },
    // Add RapidAPI configuration
    rapidApi: {
        key: 'fe15daa4admsh359f7ef5e75c711p127ec1jsn29f46cbe01c1', // Replace with your actual RapidAPI key
        host: 'judge0-ce.p.rapidapi.com'
    },
    limits: {
        cpu_time_limit: 2,
        memory_limit: 256000,
        wall_time_limit: 10,
        max_processes_and_or_threads: 30,
        enable_network: false,
        enable_per_process_and_thread_time_limit: false,
        enable_per_process_and_thread_memory_limit: false
    },
    retries: {
        maxAttempts: 3,
        interval: 1500
    }
};
// Language configurations with proper Judge0 language IDs
const LANGUAGE_CONFIG = {
    '71': { name: 'Python (3.10.0)', extension: 'py' },
    '62': { name: 'Java (OpenJDK 17)', extension: 'java' },
    '54': { name: 'C++ (GCC 11.2.0)', extension: 'cpp' },
    '63': { name: 'JavaScript (Node.js 16.13.0)', extension: 'js' },
    '51': { name: 'C# (Mono 6.12.0)', extension: 'cs' },
    '50': { name: 'C (GCC 11.2.0)', extension: 'c' }
};

// Fixed function to create a submission in Judge0
async function createSubmission(languageId, sourceCode, stdin = '') {
    try {
        console.log('Creating submission with:', {
            languageId,
            sourceCodeLength: sourceCode.length,
            stdinLength: stdin.length
        });

        if (!sourceCode || sourceCode.trim() === '') {
            throw new Error('Source code cannot be empty');
        }

        if (!languageId || !LANGUAGE_CONFIG[languageId]) {
            throw new Error('Invalid language ID');
        }

        const submissionPayload = {
            source_code: sourceCode,
            language_id: parseInt(languageId),
            stdin: stdin || '',
            expected_output: null,
        };

        console.log('Submission payload:', submissionPayload);

        // UPDATED: Add RapidAPI headers
        const response = await fetch(`${JUDGE0_CONFIG.baseUrl}${JUDGE0_CONFIG.endpoints.submissions}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                // Add RapidAPI headers
                'X-RapidAPI-Key': JUDGE0_CONFIG.rapidApi.key,
                'X-RapidAPI-Host': JUDGE0_CONFIG.rapidApi.host
            },
            body: JSON.stringify(submissionPayload)
        });

        console.log('Response status:', response.status);
        console.log('Response headers:', Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Judge0 API Error Response:', errorText);
            
            let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
            
            try {
                const errorJson = JSON.parse(errorText);
                if (errorJson.message) {
                    errorMessage = errorJson.message;
                } else if (errorJson.error) {
                    errorMessage = errorJson.error;
                } else if (errorJson.errors) {
                    errorMessage = JSON.stringify(errorJson.errors);
                }
            } catch (parseError) {
                errorMessage = errorText || errorMessage;
            }
            
            throw new Error(`Judge0 API Error: ${errorMessage}`);
        }

        const data = await response.json();
        console.log('Submission created successfully:', data);

        if (!data.token) {
            throw new Error('No token received from Judge0 API');
        }

        return data.token;
        
    } catch (error) {
        console.error('Error creating submission:', error);
        throw new Error(`Failed to create submission: ${error.message}`);
    }
}

// 3. UPDATE THE getSubmissionResult FUNCTION (around line 950)
async function getSubmissionResult(token) {
    try {
        if (!token || token === 'undefined') {
            throw new Error('Invalid token provided');
        }

        console.log('Getting submission result for token:', token);

        const url = `${JUDGE0_CONFIG.baseUrl}${JUDGE0_CONFIG.endpoints.status}/${token}?fields=stdout,stderr,status,time,memory,compile_output,message,exit_code,created_at,finished_at`;
        
        // UPDATED: Add RapidAPI headers
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                // Add RapidAPI headers
                'X-RapidAPI-Key': JUDGE0_CONFIG.rapidApi.key,
                'X-RapidAPI-Host': JUDGE0_CONFIG.rapidApi.host
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('Error getting submission result:', errorText);
            throw new Error(`Failed to get submission result: HTTP ${response.status}`);
        }

        const result = await response.json();
        console.log('Submission result:', result);
        
        return result;
        
    } catch (error) {
        console.error('Error getting submission result:', error);
        throw error;
    }
}
// Enhanced function to poll for submission result with better error handling
async function pollSubmissionResult(token) {
    if (!token || token === 'undefined') {
        throw new Error('Invalid token for polling');
    }

    let result = null;
    let attempts = 0;
    const maxAttempts = JUDGE0_CONFIG.retries.maxAttempts;
    const interval = JUDGE0_CONFIG.retries.interval;
    
    console.log(`Starting to poll for result of token: ${token}`);

    while (attempts < maxAttempts) {
        try {
            result = await getSubmissionResult(token);
            
            console.log(`Polling attempt ${attempts + 1}/${maxAttempts}, Status ID: ${result.status?.id}, Description: ${result.status?.description}`);
            
            // Status IDs in Judge0:
            // 1: In Queue
            // 2: Processing
            // 3: Accepted
            // 4: Wrong Answer
            // 5: Time Limit Exceeded
            // 6: Compilation Error
            // 7: Runtime Error (SIGSEGV)
            // 8: Runtime Error (SIGXFSZ)
            // 9: Runtime Error (SIGFPE)
            // 10: Runtime Error (SIGABRT)
            // 11: Runtime Error (NZEC)
            // 12: Runtime Error (Other)
            // 13: Internal Error
            // 14: Exec Format Error
            
            if (result.status && result.status.id > 2) {
                console.log('Submission completed with status:', result.status);
                return result;
            }
            
            // Wait before next poll
            await new Promise(resolve => setTimeout(resolve, interval));
            attempts++;
            
        } catch (error) {
            console.error(`Polling attempt ${attempts + 1} failed:`, error);
            attempts++;
            
            if (attempts >= maxAttempts) {
                throw error;
            }
            
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, interval));
        }
    }
    
    throw new Error(`Timed out waiting for submission result after ${maxAttempts} attempts`);
}

// Enhanced function to format output from Judge0
function formatOutput(result) {
    console.log('Formatting output for result:', result);
    
    if (!result || !result.status) {
        return {
            success: false,
            output: 'Invalid result data',
            executionTime: 0,
            memory: 0,
            status: 'Unknown'
        };
    }

    const status = result.status;
    const stdout = result.stdout || '';
    const stderr = result.stderr || '';
    const time = parseFloat(result.time) || 0;
    const memory = parseInt(result.memory) || 0;

    switch (status.id) {
        case 3: // Accepted
            return {
                success: true,
                output: stdout || '(No output)',
                executionTime: time,
                memory: memory,
                status: 'Accepted'
            };
            
        case 4: // Wrong Answer
            return {
                success: false,
                output: stdout || '(No output)',
                executionTime: time,
                memory: memory,
                status: 'Wrong Answer'
            };
            
        case 5: // Time Limit Exceeded
            return {
                success: false,
                output: 'Time Limit Exceeded',
                executionTime: time,
                memory: memory,
                status: 'Time Limit Exceeded'
            };
            
        case 6: // Compilation Error
            return {
                success: false,
                output: result.compile_output || 'Compilation Error',
                executionTime: 0,
                memory: 0,
                status: 'Compilation Error'
            };
            
        case 7: // Runtime Error (SIGSEGV)
        case 8: // Runtime Error (SIGXFSZ)
        case 9: // Runtime Error (SIGFPE)
        case 10: // Runtime Error (SIGABRT)
        case 11: // Runtime Error (NZEC)
        case 12: // Runtime Error (Other)
            return {
                success: false,
                output: stderr || result.message || 'Runtime Error',
                executionTime: time,
                memory: memory,
                status: `Runtime Error (${status.description})`
            };
            
        case 13: // Internal Error
            return {
                success: false,
                output: 'Judge0 Internal Error',
                executionTime: 0,
                memory: 0,
                status: 'Internal Error'
            };
            
        case 14: // Exec Format Error
            return {
                success: false,
                output: 'Executable Format Error',
                executionTime: 0,
                memory: 0,
                status: 'Exec Format Error'
            };
            
        default:
            return {
                success: false,
                output: stderr || result.message || `Unknown status: ${status.description}`,
                executionTime: time,
                memory: memory,
                status: status.description || 'Unknown'
            };
    }
}

// Enhanced function to run code with sample input
async function runCode(questionId) {
    const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
    const languageSelect = document.getElementById(`language-select-${questionId}`);
    const resultsSection = document.getElementById(`results-${questionId}`);
    const resultOutput = document.getElementById(`result-output-${questionId}`);
    
    if (!codeTextarea || !languageSelect) {
        console.error('Required elements not found');
        return;
    }

    const code = codeTextarea.value.trim();
    const languageId = languageSelect.value;
    
    // Validate inputs
    if (!code) {
        resultOutput.innerHTML = '<p class="error"><i class="fas fa-exclamation-circle"></i> Please enter some code before running.</p>';
        resultsSection.style.display = 'block';
        return;
    }

    // Get the appropriate question data
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    let question;
    
    if (examData.questionType === "coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
        question = codingQuestions.find(q => q._id == questionId);
    } else if (examData.questionType === "mcq&coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
        question = codingQuestions.find(q => q._id == questionId);
    }
    
    if (!question) {
        console.error('Question not found');
        resultOutput.innerHTML = '<p class="error"><i class="fas fa-exclamation-circle"></i> Question data not found.</p>';
        resultsSection.style.display = 'block';
        return;
    }
    
    const sampleInput = question.sampleInput || '';
    
    // Show loading message
    resultOutput.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Running your code...</div>';
    resultsSection.style.display = 'block';
    
    try {
        // Create submission
        console.log('Creating submission for sample input...');
        const token = await createSubmission(languageId, code, sampleInput);
        
        if (!token) {
            throw new Error('Failed to get submission token');
        }
        
        // Poll for result
        console.log('Polling for result...');
        const result = await pollSubmissionResult(token);
        
        // Format and display result
        const formattedResult = formatOutput(result);
        
        let statusClass = formattedResult.success ? 'result-pass' : 'result-fail';
        
        let outputHtml = `
            <h4 class="section-title"><i class="fas fa-terminal"></i> Execution Result:</h4>
            <div class="execution-status ${statusClass}">
                <i class="fas fa-${formattedResult.success ? 'check' : 'times'}-circle"></i>
                Status: ${formattedResult.status}
            </div>
            <pre class="execution-output">${escapeHtml(formattedResult.output)}</pre>
            <div class="execution-details">
                <p><i class="fas fa-clock"></i> Execution Time: ${formattedResult.executionTime}s</p>
                <p><i class="fas fa-memory"></i> Memory Used: ${Math.round(formattedResult.memory / 1000)}KB</p>
            </div>
        `;
        
        // Compare with expected output if available and execution was successful
        if (question.sampleOutput && formattedResult.success) {
            const isCorrect = compareOutputs(question.sampleOutput, formattedResult.output);
            
            outputHtml += `<div class="comparison-result">
                <p>Sample Test: <span class="${isCorrect ? 'result-pass' : 'result-fail'}">
                    <i class="fas fa-${isCorrect ? 'check' : 'times'}-circle"></i> 
                    ${isCorrect ? 'PASSED' : 'FAILED'}
                </span></p>
            </div>`;
            
            if (!isCorrect) {
                outputHtml += '<div id="diff-container-' + questionId + '"></div>';
            }
        }
        
        resultOutput.innerHTML = outputHtml;
        
        // Add diff view if test failed
        if (question.sampleOutput && formattedResult.success && !compareOutputs(question.sampleOutput, formattedResult.output)) {
            const diffContainer = document.getElementById(`diff-container-${questionId}`);
            if (diffContainer) {
                diffContainer.appendChild(displayDiff(question.sampleOutput, formattedResult.output));
            }
        }
        
    } catch (error) {
        console.error('Error running code:', error);
        resultOutput.innerHTML = `<p class="error"><i class="fas fa-exclamation-circle"></i> Error: ${error.message}</p>`;
    }
}

// Enhanced function to run code with custom input
async function runCodeWithCustomInput(questionId) {
    const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
    const languageSelect = document.getElementById(`language-select-${questionId}`);
    const customInput = document.getElementById(`custom-input-${questionId}`);
    const resultsSection = document.getElementById(`results-${questionId}`);
    const resultOutput = document.getElementById(`result-output-${questionId}`);
    
    if (!codeTextarea || !languageSelect || !customInput) {
        console.error('Required elements not found');
        return;
    }

    const code = codeTextarea.value.trim();
    const languageId = languageSelect.value;
    const stdin = customInput.value;
    
    // Validate inputs
    if (!code) {
        resultOutput.innerHTML = '<p class="error"><i class="fas fa-exclamation-circle"></i> Please enter some code before running.</p>';
        resultsSection.style.display = 'block';
        return;
    }
    
    // Show loading message
    resultOutput.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Running your code with custom input...</div>';
    resultsSection.style.display = 'block';
    
    try {
        // Create submission
        console.log('Creating submission for custom input...');
        const token = await createSubmission(languageId, code, stdin);
        
        if (!token) {
            throw new Error('Failed to get submission token');
        }
        
        // Poll for result
        console.log('Polling for result...');
        const result = await pollSubmissionResult(token);
        
        // Format and display result
        const formattedResult = formatOutput(result);
        
        let statusClass = formattedResult.success ? 'result-pass' : 'result-fail';
        
        let outputHtml = `
            <h4 class="section-title"><i class="fas fa-keyboard"></i> Custom Test Result:</h4>
            <div class="execution-status ${statusClass}">
                <i class="fas fa-${formattedResult.success ? 'check' : 'times'}-circle"></i>
                Status: ${formattedResult.status}
            </div>
            <pre class="execution-output">${escapeHtml(formattedResult.output)}</pre>
            <div class="execution-details">
                <p><i class="fas fa-clock"></i> Execution Time: ${formattedResult.executionTime}s</p>
                <p><i class="fas fa-memory"></i> Memory Used: ${Math.round(formattedResult.memory / 1000)}KB</p>
            </div>
        `;
        
        resultOutput.innerHTML = outputHtml;
        
    } catch (error) {
        console.error('Error running code with custom input:', error);
        resultOutput.innerHTML = `<p class="error"><i class="fas fa-exclamation-circle"></i> Error: ${error.message}</p>`;
    }
}

// Enhanced function to run all test cases
async function runAllTests(questionId) {
    const codeTextarea = document.getElementById(`codeEditor-${questionId}`);
    const languageSelect = document.getElementById(`language-select-${questionId}`);
    const resultsSection = document.getElementById(`results-${questionId}`);
    const resultOutput = document.getElementById(`result-output-${questionId}`);
    const testResultsSection = document.getElementById(`test-results-${questionId}`);
    const testResultsBody = document.getElementById(`test-results-body-${questionId}`);
    
    if (!codeTextarea || !languageSelect) {
        console.error('Code editor or language selector not found');
        return;
    }
    
    const code = codeTextarea.value.trim();
    const languageId = languageSelect.value;
    
    // Validate inputs
    if (!code) {
        resultOutput.innerHTML = '<p class="error"><i class="fas fa-exclamation-circle"></i> Please enter some code before running tests.</p>';
        resultsSection.style.display = 'block';
        return;
    }
    
    // Get the appropriate question data
    const examData = JSON.parse(localStorage.getItem('currentExam'));
    let question;
    
    if (examData.questionType === "coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
        question = codingQuestions.find(q => q._id == questionId);
    } else if (examData.questionType === "mcq&coding") {
        const codingQuestions = JSON.parse(localStorage.getItem('codingQuestions'));
        question = codingQuestions.find(q => q._id == questionId);
    }
    
    // Check if question has test cases
    if (!question || !question.testCases || question.testCases.length === 0) {
        resultOutput.innerHTML = '<p class="error"><i class="fas fa-exclamation-circle"></i> No test cases available for this question.</p>';
        resultsSection.style.display = 'block';
        return;
    }
    
    // Show loading message
    resultOutput.innerHTML = '<div class="loading-spinner"><i class="fas fa-spinner fa-spin"></i> Running all test cases...</div>';
    resultsSection.style.display = 'block';
    testResultsSection.style.display = 'block';
    testResultsBody.innerHTML = '';
    
    let allTestsPassed = true;
    let totalTime = 0;
    let maxMemory = 0;
    let passedTests = 0;
    
    // Run all test cases
    for (let i = 0; i < question.testCases.length; i++) {
        const testCase = question.testCases[i];
        
        try {
            // Create row with loading state
            const row = document.createElement('tr');
            row.id = `test-row-${questionId}-${i}`;
            row.innerHTML = `
                <td>Test Case ${i + 1}${testCase.isPublic ? ' (Public)' : ' (Hidden)'}</td>
                <td colspan="4"><i class="fas fa-spinner fa-spin"></i> Running...</td>
            `;
            testResultsBody.appendChild(row);
            
            // Create submission for this test case
            console.log(`Creating submission for test case ${i + 1}...`);
            const token = await createSubmission(languageId, code, testCase.input);
            
            if (!token) {
                throw new Error('Failed to get submission token');
            }
            
            // Poll for result
            console.log(`Polling for test case ${i + 1} result...`);
            const result = await pollSubmissionResult(token);
            
            // Format result
            const formattedResult = formatOutput(result);
            
            // Check if output matches expected output (only if execution was successful)
            let isCorrect = false;
            if (formattedResult.success) {
                isCorrect = compareOutputs(testCase.expectedOutput, formattedResult.output);
                if (isCorrect) {
                    passedTests++;
                }
            }
            
            // Update aggregate statistics
            totalTime += parseFloat(formattedResult.executionTime || 0);
            maxMemory = Math.max(maxMemory, formattedResult.memory || 0);
            
            // If any test fails, mark all tests as failed
            if (!isCorrect) {
                allTestsPassed = false;
            }
            
            // Update the row with results
            row.innerHTML = `
                <td>Test Case ${i + 1}${testCase.isPublic ? ' (Public)' : ' (Hidden)'}</td>
                <td class="${isCorrect ? 'result-pass' : 'result-fail'}">
                    <i class="fas fa-${isCorrect ? 'check' : 'times'}-circle"></i> 
                    ${isCorrect ? 'PASS' : (formattedResult.success ? 'FAIL' : formattedResult.status)}
                </td>
                <td>${formattedResult.executionTime}s</td>
                <td>${Math.round(formattedResult.memory / 1000)}KB</td>
                <td><span class="test-details-link" data-test-id="${questionId}-${i}">View Details</span></td>
            `;
            
            // Create hidden details div
            const detailsDiv = document.createElement('div');
            detailsDiv.id = `test-details-${questionId}-${i}`;
            detailsDiv.style.display = 'none';
            detailsDiv.className = 'test-case-details-container';
            
            detailsDiv.innerHTML = `
                <h4>Test Case ${i + 1} Details</h4>
                <div class="test-case-status">
                    <p><strong>Status:</strong> ${formattedResult.status}</p>
                </div>
                <div class="test-case-input">
                    <h5>Input:</h5>
                    <pre>${escapeHtml(testCase.input)}</pre>
                </div>
                <div class="test-case-output">
                    <h5>Expected Output:</h5>
                    <pre>${escapeHtml(testCase.expectedOutput)}</pre>
                </div>
                <div class="test-case-actual">
                    <h5>Your Output:</h5>
                    <pre>${escapeHtml(formattedResult.output)}</pre>
                </div>
            `;
            
            // If test failed and execution was successful, add diff view
            if (!isCorrect && formattedResult.success) {
                detailsDiv.appendChild(displayDiff(testCase.expectedOutput, formattedResult.output));
            }
            
            testResultsSection.appendChild(detailsDiv);
            
        } catch (error) {
            console.error('Error running test case:', error);
            allTestsPassed = false;
            
            // Update row with error
            const row = document.getElementById(`test-row-${questionId}-${i}`) || document.createElement('tr');
            row.innerHTML = `
                <td>Test Case ${i + 1}${testCase.isPublic ? ' (Public)' : ' (Hidden)'}</td>
                <td class="result-fail"><i class="fas fa-times-circle"></i> ERROR</td>
                <td>-</td>
                <td>-</td>
                <td>${error.message}</td>
            `;
            
            if (!row.parentNode) {
                testResultsBody.appendChild(row);
            }
        }
    }
    
    // Update overall result
    resultOutput.innerHTML = `
        <div class="result-summary">
            <h4><i class="fas fa-clipboard-check"></i> Overall Result:</h4>
            <p class="${allTestsPassed ? 'result-pass' : 'result-fail'}">
                <i class="fas fa-${allTestsPassed ? 'check' : 'times'}-circle"></i> 
                ${passedTests}/${question.testCases.length} test cases passed
            </p>
            <div class="execution-details">
                <p><i class="fas fa-clock"></i> Total Execution Time: ${totalTime.toFixed(3)}s</p>
                <p><i class="fas fa-memory"></i> Max Memory Used: ${Math.round(maxMemory / 1000)}KB</p>
            </div>
        </div>
    `;
    
    // Add event listeners to the "View Details" links
    document.querySelectorAll('.test-details-link').forEach(link => {
        link.addEventListener('click', function() {
            const testId = this.getAttribute('data-test-id');
            const detailsDiv = document.getElementById(`test-details-${testId}`);
            
            // Toggle display
            if (detailsDiv) {
                detailsDiv.style.display = detailsDiv.style.display === 'none' ? 'block' : 'none';
            }
        });
    });
}
 
    // Function to compare expected output with actual output
    function compareOutputs(expected, actual) {
        // Normalize line endings and trim whitespace
        expected = expected.replace(/\r\n/g, '\n').trim();
        actual = actual.replace(/\r\n/g, '\n').trim();
        
        return expected === actual;
    }
    
    // Function to display pretty diff between expected and actual output
    function displayDiff(expected, actual) {
        const diff = document.createElement('div');
        diff.className = 'diff-view';
        
        const expectedDiv = document.createElement('div');
        expectedDiv.className = 'diff-expected';
        expectedDiv.innerHTML = `<h4>Expected Output:</h4><pre>${escapeHtml(expected)}</pre>`;
        
        const actualDiv = document.createElement('div');
        actualDiv.className = 'diff-actual';
        actualDiv.innerHTML = `<h4>Your Output:</h4><pre>${escapeHtml(actual)}</pre>`;
        
        diff.appendChild(expectedDiv);
        diff.appendChild(actualDiv);
        
        return diff;
    }

    // Helper function to escape HTML for safe display
    function escapeHtml(string) {
        return string
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
   // Function to run code with sample input



    // Add these styles for the modal and messages
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Modal Styles */
        .modal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .modal-content {
            background-color: white;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            z-index: 1001;
            box-shadow: var(--shadow-lg);
            animation: modalFadeIn 0.3s;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .modal-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }
        
        .modal-close {
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--secondary);
        }
        
        .modal-body {
            padding: 1.5rem;
        }
        
        .modal-footer {
            padding: 1rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }
        
        .modal-body .warning {
            color: var(--danger);
            background-color: #fee2e2;
            padding: 0.75rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Message Styles */
        .message-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            max-width: 300px;
            z-index: 1000;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            transform: translateX(110%);
            transition: transform 0.3s ease;
        }
        
        .message-container.show {
            transform: translateX(0);
        }
        
        .message-content {
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .success-message .message-content {
            background-color: #ecfdf5;
            color: #064e3b;
            border-left: 4px solid #10b981;
        }
        
        .error-message .message-content {
            background-color: #fef2f2;
            color: #7f1d1d;
            border-left: 4px solid #ef4444;
        }
        
        /* Loading Spinner */
        .loading-spinner {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--primary);
            margin: 1rem 0;
        }
        
        /* Dark Theme Styles */
        body.dark-theme {
            background-color: #1e1e2d;
            color: #e5e7eb;
        }
        
        body.dark-theme .header,
        body.dark-theme .question-panel,
        body.dark-theme .sidebar-card {
            background-color: #252636;
            color: #e5e7eb;
        }
        
        body.dark-theme .nav-button {
            background-color: #2d2d3f;
            color: #e5e7eb;
            border-color: #374151;
        }
        
        body.dark-theme .nav-button:hover {
            background-color: #374151;
        }
        
        body.dark-theme pre {
            background-color: #1a1a2e;
            border-color: #374151;
            color: #e5e7eb;
        }
        
        body.dark-theme .mcq-option {
            background-color: #2d2d3f;
            border-color: #374151;
        }
        
        body.dark-theme .mcq-option:hover {
            background-color: #374151;
        }
        
        body.dark-theme .mcq-option.selected {
            background-color: #3b82f6;
            border-color: #2563eb;
            color: white;
        }
        
        body.dark-theme .btn-secondary {
            background-color: #374151;
            color: #e5e7eb;
            border-color: #4b5563;
        }
        
        body.dark-theme .btn-secondary:hover {
            background-color: #4b5563;
        }
        
        body.dark-theme .code-textarea {
            background-color: #1e1e1e;
            color: #e5e7eb;
            border-color: #374151;
        }
        
        body.dark-theme .test-results-table th,
        body.dark-theme .test-results-table td {
            border-color: #374151;
        }
        
        body.dark-theme .test-results-table th {
            background-color: #2d2d3f;
        }
        
        body.dark-theme .diff-expected {
            background-color: #064e3b;
            border-color: #10b981;
        }
        
        body.dark-theme .diff-actual {
            background-color: #7f1d1d;
            border-color: #ef4444;
        }
        
        body.dark-theme .dark-mode-toggle {
            color: #e5e7eb;
        }
        
        body.dark-theme .dark-mode-toggle:hover {
            background-color: #374151;
        }
        
        body.dark-theme .timer-display {
            background-color: #2d2d3f;
            color: #e5e7eb;
        }
        
        body.dark-theme .modal-content {
            background-color: #252636;
            color: #e5e7eb;
        }
        
        body.dark-theme .modal-header,
        body.dark-theme .modal-footer {
            border-color: #374151;
        }
    `;
    document.head.appendChild(styleElement);

    </script>
</body>
</html>